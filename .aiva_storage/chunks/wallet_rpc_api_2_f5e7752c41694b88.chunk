llet_id, my_did=my_did)

    @marshal
    async def did_get_metadata(self, request: DIDGetMetadata) -> DIDGetMetadataResponse:
        wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=DIDWallet)
        metadata = json.loads(wallet.did_info.metadata)
        return DIDGetMetadataResponse(
            wallet_id=request.wallet_id,
            metadata=metadata,
        )

    @marshal
    async def did_get_pubkey(self, request: DIDGetPubkey) -> DIDGetPubkeyResponse:
        wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=DIDWallet)
        return DIDGetPubkeyResponse(
            (await wallet.wallet_state_manager.get_unused_derivation_record(request.wallet_id)).pubkey
        )

    @marshal
    async def did_get_current_coin_info(self, request: DIDGetCurrentCoinInfo) -> DIDGetCurrentCoinInfoResponse:
        did_wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=DIDWallet)
        my_did = encode_puzzle_hash(
            bytes32.from_hexstr(did_wallet.get_my_DID()), AddressType.DID.hrp(self.service.config)
        )

        assert did_wallet.did_info.current_inner is not None
        parent_coin = await did_wallet.get_coin()
        assert my_did is not None
        return DIDGetCurrentCoinInfoResponse(
            wallet_id=request.wallet_id,
            my_did=my_did,
            did_parent=parent_coin.parent_coin_info,
            did_innerpuz=did_wallet.did_info.current_inner.get_tree_hash(),
            did_amount=parent_coin.amount,
        )

    @marshal
    async def did_create_backup_file(self, request: DIDCreateBackupFile) -> DIDCreateBackupFileResponse:
        did_wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=DIDWallet)
        return DIDCreateBackupFileResponse(wallet_id=request.wallet_id, backup_data=did_wallet.create_backup())

    @tx_endpoint(push=True)
    @marshal
    async def did_transfer_did(
        self,
        request: DIDTransferDID,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> DIDTransferDIDResponse:
        did_wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=DIDWallet)
        puzzle_hash: bytes32 = decode_puzzle_hash(request.inner_address)
        async with self.service.wallet_state_manager.lock:
            await did_wallet.transfer_did(
                puzzle_hash,
                request.fee,
                action_scope,
                extra_conditions=extra_conditions,
            )

        # The tx_endpoint wrapper will take care of these default values
        return DIDTransferDIDResponse([], [], transaction=REPLACEABLE_TRANSACTION_RECORD, transaction_id=bytes32.zeros)

    ##########################################################################################
    # NFT Wallet
    ##########################################################################################
    @tx_endpoint(push=True)
    @marshal
    async def nft_mint_nft(
        self,
        request: NFTMintNFTRequest,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> NFTMintNFTResponse:
        log.debug("Got minting RPC request: %s", request)
        assert self.service.wallet_state_manager
        nft_wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=NFTWallet)
        if request.royalty_amount == 10000:
            raise ValueError("Royalty percentage cannot be 100%")
        if request.royalty_address is not None:
            royalty_puzhash = decode_puzzle_hash(request.royalty_address)
        else:
            royalty_puzhash = await action_scope.get_puzzle_hash(self.service.wallet_state_manager)
        if request.target_address is not None:
            target_puzhash = decode_puzzle_hash(request.target_address)
        else:
            target_puzhash = await action_scope.get_puzzle_hash(self.service.wallet_state_manager)
        metadata_list = [
            ("u", request.uris),
            ("h", request.hash),
            ("mu", request.meta_uris),
            ("lu", request.license_uris),
            ("sn", request.edition_number),
            ("st", request.edition_total),
        ]
        if request.meta_hash is not None:
            metadata_list.append(("mh", request.meta_hash))
        if request.license_hash is not None:
            metadata_list.append(("lh", request.license_hash))
        metadata = Program.to(metadata_list)
        if request.did_id is not None:
            if request.did_id == "":
                did_id: Optional[bytes] = b""
            else:
                did_id = decode_puzzle_hash(request.did_id)
        else:
            did_id = request.did_id

        nft_id = await nft_wallet.generate_new_nft(
            metadata,
            action_scope,
            target_puzhash,
            royalty_puzhash,
            request.royalty_amount,
            did_id,
            request.fee,
            extra_conditions=extra_conditions,
        )
        nft_id_bech32 = encode_puzzle_hash(nft_id, AddressType.NFT.hrp(self.service.config))
        return NFTMintNFTResponse(
            [],
            [],
            wallet_id=request.wallet_id,
            spend_bundle=WalletSpendBundle([], G2Element()),  # tx_endpoint wrapper will take care of this
            nft_id=nft_id_bech32,
        )

    @marshal
    async def nft_count_nfts(self, request: NFTCountNFTs) -> NFTCountNFTsResponse:
        count = 0
        if request.wallet_id is not None:
            try:
                nft_wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=NFTWallet)
            except KeyError:
                # wallet not found
                raise ValueError(f"Wallet {request.wallet_id} not found.")
            count = await nft_wallet.get_nft_count()
        else:
            count = await self.service.wallet_state_manager.nft_store.count()
        return NFTCountNFTsResponse(request.wallet_id, uint64(count))

    @marshal
    async def nft_get_nfts(self, request: NFTGetNFTs) -> NFTGetNFTsResponse:
        nfts: list[NFTCoinInfo] = []
        if request.wallet_id is not None:
            nft_wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=NFTWallet)
        else:
            nft_wallet = None
        nft_info_list = []
        if nft_wallet is not None:
            nfts = await nft_wallet.get_current_nfts(start_index=request.start_index, count=request.num)
        else:
            nfts = await self.service.wallet_state_manager.nft_store.get_nft_list(
                start_index=request.start_index, count=request.num
            )
        for nft in nfts:
            nft_info = await nft_puzzle_utils.get_nft_info_from_puzzle(nft, self.service.wallet_state_manager.config)
            nft_info_list.append(nft_info)
        return NFTGetNFTsResponse(request.wallet_id, nft_info_list)

    @tx_endpoint(push=True)
    @marshal
    async def nft_set_nft_did(
        self,
        request: NFTSetNFTDID,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> NFTSetNFTDIDResponse:
        nft_wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=NFTWallet)
        if request.did_id is not None:
            did_id: bytes = decode_puzzle_hash(request.did_id)
        else:
            did_id = b""
        nft_coin_info = await nft_wallet.get_nft_coin_by_id(request.nft_coin_id)
        if not (
            await nft_puzzle_utils.get_nft_info_from_puzzle(nft_coin_info, self.service.wallet_state_manager.config)
        ).supports_did:
            raise ValueError("The NFT doesn't support setting a DID.")

        await nft_wallet.set_nft_did(
            nft_coin_info,
            did_id,
            action_scope,
            fee=request.fee,
            extra_conditions=extra_conditions,
        )
        # tx_endpoint wrapper takes care of setting most of these default values
        return NFTSetNFTDIDResponse([], [], request.wallet_id, WalletSpendBundle([], G2Element()))

    @tx_endpoint(push=True)
    @marshal
    async def nft_set_did_bulk(
        self,
        request: NFTSetDIDBulk,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> NFTSetDIDBulkResponse:
        """
        Bulk set DID for NFTs across different wallets.
        accepted `request` dict keys:
         - required `nft_coin_list`: [{"nft_coin_id": COIN_ID/NFT_ID, "wallet_id": WALLET_ID},....]
         - optional `fee`, in mojos, defaults to 0
         - optional `did_id`, defaults to no DID, meaning it will reset the NFT's DID
        :param request:
        :return:
        """
        if len(request.nft_coin_list) > MAX_NFT_CHUNK_SIZE:
            raise ValueError(f"You can only set {MAX_NFT_CHUNK_SIZE} NFTs at once")

        if request.did_id is not None:
            did_id: bytes = decode_puzzle_hash(request.did_id)
        else:
            did_id = b""
        nft_dict: dict[uint32, list[NFTCoinInfo]] = {}
        coin_ids = []
        nft_ids = []

        nft_wallet: NFTWallet
        for nft_coin in request.nft_coin_list:
            nft_wallet = self.service.wallet_state_manager.get_wallet(id=nft_coin.wallet_id, required_type=NFTWallet)
            if nft_coin.nft_coin_id.startswith(AddressType.NFT.hrp(self.service.config)):
                nft_coin_info = await nft_wallet.get_nft(decode_puzzle_hash(nft_coin.nft_coin_id))
            else:
                nft_coin_info = await nft_wallet.get_nft_coin_by_id(bytes32.from_hexstr(nft_coin.nft_coin_id))
            assert nft_coin_info is not None
            if not (
                await nft_puzzle_utils.get_nft_info_from_puzzle(nft_coin_info, self.service.wallet_state_manager.config)
            ).supports_did:
                log.warning(f"Skipping NFT {nft_coin_info.nft_id.hex()}, doesn't support setting a DID.")
                continue
            if nft_coin.wallet_id in nft_dict:
                nft_dict[nft_coin.wallet_id].append(nft_coin_info)
            else:
                nft_dict[nft_coin.wallet_id] = [nft_coin_info]
            nft_ids.append(nft_coin_info.nft_id)
        first = True
        for wallet_id, nft_list in nft_dict.items():
            nft_wallet = self.service.wallet_state_manager.get_wallet(id=wallet_id, required_type=NFTWallet)
            if not first:
                await nft_wallet.set_bulk_nft_did(nft_list, did_id, action_scope, extra_conditions=extra_conditions)
            else:
                await nft_wallet.set_bulk_nft_did(
                    nft_list, did_id, action_scope, request.fee, nft_ids, extra_conditions=extra_conditions
                )
            for coin in nft_list:
                coin_ids.append(coin.coin.name())
            first = False

        for id in coin_ids:
            await nft_wallet.update_coin_status(id, True)
        for wallet_id in nft_dict.keys():
            self.service.wallet_state_manager.state_changed("nft_coin_did_set", wallet_id)

        async with action_scope.use() as interface:
            return NFTSetDIDBulkResponse(
                [],
                [],
                wallet_id=list(nft_dict.keys()),
                spend_bundle=WalletSpendBundle([], G2Element()),
                tx_num=uint16(len(interface.side_effects.transactions)),
            )

    @tx_endpoint(push=True)
    @marshal
    async def nft_transfer_bulk(
        self,
        request: NFTTransferBulk,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> NFTTransferBulkResponse:
        """
        Bulk transfer NFTs to an address.
        accepted `request` dict keys:
         - required `nft_coin_list`: [{"nft_coin_id": COIN_ID/NFT_ID, "wallet_id": WALLET_ID},....]
         - required `target_address`, Transfer NFTs to this address
         - optional `fee`, in mojos, defaults to 0
        :param request:
        :return:
        """
        if len(request.nft_coin_list) > MAX_NFT_CHUNK_SIZE:
            raise ValueError(f"You can only transfer {MAX_NFT_CHUNK_SIZE} NFTs at once")
        address = request.target_address
        puzzle_hash = decode_puzzle_hash(address)
        nft_dict: dict[uint32, list[NFTCoinInfo]] = {}
        coin_ids = []

        nft_wallet: NFTWallet
        for nft_coin in request.nft_coin_list:
            nft_wallet = self.service.wallet_state_manager.get_wallet(id=nft_coin.wallet_id, required_type=NFTWallet)
            nft_coin_id = nft_coin.nft_coin_id
            if nft_coin_id.startswith(AddressType.NFT.hrp(self.service.config)):
                nft_coin_info = await nft_wallet.get_nft(decode_puzzle_hash(nft_coin_id))
            else:
                nft_coin_info = await nft_wallet.get_nft_coin_by_id(bytes32.from_hexstr(nft_coin_id))
            assert nft_coin_info is not None
            if nft_coin.wallet_id in nft_dict:
                nft_dict[nft_coin.wallet_id].append(nft_coin_info)
            else:
                nft_dict[nft_coin.wallet_id] = [nft_coin_info]
        first = True
        for wallet_id, nft_list in nft_dict.items():
            nft_wallet = self.service.wallet_state_manager.get_wallet(id=wallet_id, required_type=NFTWallet)
            if not first:
                await nft_wallet.bulk_transfer_nft(
                    nft_list, puzzle_hash, action_scope, extra_conditions=extra_conditions
                )
            else:
                await nft_wallet.bulk_transfer_nft(
                    nft_list, puzzle_hash, action_scope, request.fee, extra_conditions=extra_conditions
                )
            for coin in nft_list:
                coin_ids.append(coin.coin.name())
            first = False

        for id in coin_ids:
            await nft_wallet.update_coin_status(id, True)
        for wallet_id in nft_dict.keys():
            self.service.wallet_state_manager.state_changed("nft_coin_did_set", wallet_id)
        async with action_scope.use() as interface:
            return NFTTransferBulkResponse(
                [],
                [],
                wallet_id=list(nft_dict.keys()),
                spend_bundle=WalletSpendBundle([], G2Element()),
                tx_num=uint16(len(interface.side_effects.transactions)),
            )

    @marshal
    async def nft_get_by_did(self, request: NFTGetByDID) -> NFTGetByDIDResponse:
        did_id: Optional[bytes32] = None
        if request.did_id is not None:
            did_id = decode_puzzle_hash(request.did_id)
        for wallet in self.service.wallet_state_manager.wallets.values():
            if isinstance(wallet, NFTWallet) and wallet.get_did() == did_id:
                return NFTGetByDIDResponse(uint32(wallet.wallet_id))
        raise ValueError(f"Cannot find a NFT wallet DID = {did_id}")

    @marshal
    async def nft_get_wallet_did(self, request: NFTGetWalletDID) -> NFTGetWalletDIDResponse:
        nft_wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=NFTWallet)
        did_bytes: Optional[bytes32] = nft_wallet.get_did()
        did_id = ""
        if did_bytes is not None:
            did_id = encode_puzzle_hash(did_bytes, AddressType.DID.hrp(self.service.config))
        return NFTGetWalletDIDResponse(None if len(did_id) == 0 else did_id)

    @marshal
    async def nft_get_wallets_with_dids(self, request: Empty) -> NFTGetWalletsWithDIDsResponse:
        all_wallets = self.service.wallet_state_manager.wallets.values()
        did_wallets_by_did_id: dict[bytes32, uint32] = {}

        for wallet in all_wallets:
            if wallet.type() == WalletType.DECENTRALIZED_ID:
                assert isinstance(wallet, DIDWallet)
                if wallet.did_info.origin_coin is not None:
                    did_wallets_by_did_id[wallet.did_info.origin_coin.name()] = wallet.id()

        did_nft_wallets: list[NFTWalletWithDID] = []
        for wallet in all_wallets:
            if isinstance(wallet, NFTWallet):
                nft_wallet_did: Optional[bytes32] = wallet.get_did()
                if nft_wallet_did is not None:
                    did_wallet_id: uint32 = did_wallets_by_did_id.get(nft_wallet_did, uint32(0))
                    if did_wallet_id == 0:
                        log.warning(f"NFT wallet {wallet.id()} has DID {nft_wallet_did.hex()} but no DID wallet")
                    else:
                        did_nft_wallets.append(
                            NFTWalletWithDID(
                                wallet_id=wallet.id(),
                                did_id=encode_puzzle_hash(nft_wallet_did, AddressType.DID.hrp(self.service.config)),
                                did_wallet_id=did_wallet_id,
                            )
                        )
        return NFTGetWalletsWithDIDsResponse(did_nft_wallets)

    @marshal
    async def nft_set_nft_status(self, request: NFTSetNFTStatus) -> Empty:
        assert self.service.wallet_state_manager is not None
        nft_wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=NFTWallet)
        await nft_wallet.update_coin_status(request.coin_id, request.in_transaction)
        return Empty()

    @tx_endpoint(push=True)
    @marshal
    async def nft_transfer_nft(
        self,
        request: NFTTransferNFT,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> NFTTransferNFTResponse:
        puzzle_hash = decode_puzzle_hash(request.target_address)
        nft_wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=NFTWallet)
        nft_coin_id = request.nft_coin_id
        if nft_coin_id.startswith(AddressType.NFT.hrp(self.service.config)):
            nft_coin_info = await nft_wallet.get_nft(decode_puzzle_hash(nft_coin_id))
        else:
            nft_coin_info = await nft_wallet.get_nft_coin_by_id(bytes32.from_hexstr(nft_coin_id))
        assert nft_coin_info is not None

        await nft_wallet.generate_signed_transaction(
            [uint64(nft_coin_info.coin.amount)],
            [puzzle_hash],
            action_scope,
            coins={nft_coin_info.coin},
            fee=request.fee,
            new_owner=b"",
            new_did_inner_hash=b"",
            extra_conditions=extra_conditions,
        )
        await nft_wallet.update_coin_status(nft_coin_info.coin.name(), True)
        # tx_endpoint takes care of filling in default values here
        return NFTTransferNFTResponse([], [], request.wallet_id, WalletSpendBundle([], G2Element()))

    @marshal
    async def nft_get_info(self, request: NFTGetInfo) -> NFTGetInfoResponse:
        if request.coin_id.startswith(AddressType.NFT.hrp(self.service.config)):
            coin_id = decode_puzzle_hash(request.coin_id)
        else:
            try:
                coin_id = bytes32.from_hexstr(request.coin_id)
            except ValueError:
                raise ValueError(f"Invalid Coin ID format for 'coin_id': {request.coin_id!r}")
        # Get coin state
        peer = self.service.get_full_node_peer()
        coin_spend, coin_state = await self.get_latest_singleton_coin_spend(peer, coin_id, request.latest)
        # convert to NFTInfo
        # Check if the metadata is updated
        full_puzzle: Program = Program.from_bytes(bytes(coin_spend.puzzle_reveal))

        uncurried_nft: Optional[UncurriedNFT] = UncurriedNFT.uncurry(*full_puzzle.uncurry())
        if uncurried_nft is None:
            raise ValueError("The coin is not a NFT.")
        metadata, p2_puzzle_hash = get_metadata_and_phs(uncurried_nft, coin_spend.solution)
        # Note: This is not the actual unspent NFT full puzzle.
        # There is no way to rebuild the full puzzle in a different wallet.
        # But it shouldn't have impact on generating the NFTInfo, since inner_puzzle is not used there.
        if uncurried_nft.supports_did:
            inner_puzzle = nft_puzzle_utils.recurry_nft_puzzle(
                uncurried_nft, Program.from_serialized(coin_spend.solution), uncurried_nft.p2_puzzle
            )
        else:
            inner_puzzle = uncurried_nft.p2_puzzle

        full_puzzle = nft_puzzle_utils.create_full_puzzle(
            uncurried_nft.singleton_launcher_id,
            metadata,
            bytes32(uncurried_nft.metadata_updater_hash.as_atom()),
            inner_puzzle,
        )

        # Get launcher coin
        launcher_coin: list[CoinState] = await self.service.wallet_state_manager.wallet_node.get_coin_state(
            [uncurried_nft.singleton_launcher_id], peer=peer
        )
        if launcher_coin is None or len(launcher_coin) < 1 or launcher_coin[0].spent_height is None:
            raise ValueError(f"Launcher coin record 0x{uncurried_nft.singleton_launcher_id.hex()} not found")
        minter_did = await self.service.wallet_state_manager.get_minter_did(launcher_coin[0].coin, peer)

        nft_info: NFTInfo = await nft_puzzle_utils.get_nft_info_from_puzzle(
            NFTCoinInfo(
                uncurried_nft.singleton_launcher_id,
                coin_state.coin,
                None,
                full_puzzle,
                uint32(launcher_coin[0].spent_height),
                minter_did,
                uint32(coin_state.created_height) if coin_state.created_height else uint32(0),
            ),
            self.service.wallet_state_manager.config,
        )
        # This is a bit hacky, it should just come out like this, but this works for this RPC
        nft_info = dataclasses.replace(nft_info, p2_address=p2_puzzle_hash)
        return NFTGetInfoResponse(nft_info)

    @tx_endpoint(push=True)
    @marshal
    async def nft_add_uri(
        self,
        request: NFTAddURI,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> NFTAddURIResponse:
        # Note metadata updater can only add one uri for one field per spend.
        # If you want to add multiple uris for one field, you need to spend multiple times.
        nft_wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=NFTWallet)
        if request.nft_coin_id.startswith(AddressType.NFT.hrp(self.service.config)):
            nft_coin_id = decode_puzzle_hash(request.nft_coin_id)
        else:
            nft_coin_id = bytes32.from_hexstr(request.nft_coin_id)
        nft_coin_info = await nft_wallet.get_nft_coin_by_id(nft_coin_id)

        await nft_wallet.update_metadata(
            nft_coin_info, request.key, request.uri, action_scope, fee=request.fee, extra_conditions=extra_conditions
        )
        # tx_endpoint takes care of setting the default values here
        return NFTAddURIResponse([], [], request.wallet_id, WalletSpendBundle([], G2Element()))

    @marshal
    async def nft_calculate_royalties(self, request: NFTCalculateRoyalties) -> NFTCalculateRoyaltiesResponse:
        return NFTCalculateRoyaltiesResponse.from_json_dict(
            NFTWallet.royalty_calculation(
                {
                    asset.asset: (asset.royalty_address, uint16(asset.royalty_percentage))
                    for asset in request.royalty_assets
                },
                {asset.asset: asset.amount for asset in request.fungible_assets},
            )
        )

    @tx_endpoint(push=False)
    @marshal
    async def nft_mint_bulk(
        self,
        request: NFTMintBulk,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> NFTMintBulkResponse:
        if action_scope.config.push:
            raise ValueError("Automatic pushing of nft minting transactions not yet available")  # pragma: no cover
        nft_wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=NFTWallet)
        if request.royalty_address in {None, ""}:
            royalty_puzhash = await action_scope.get_puzzle_hash(self.service.wallet_state_manager)
        else:
            assert request.royalty_address is not None  # hello mypy
            royalty_puzhash = decode_puzzle_hash(request.royalty_address)
        metadata_list = []
        for meta in request.metadata_list:
            nft_metadata = [
                ("u", meta.uris),
                ("h", meta.hash),
                ("mu", meta.meta_uris),
                ("lu", meta.license_uris),
                ("sn", meta.edition_number),
                ("st", meta.edition_total),
            ]
            if meta.meta_hash is not None:
                nft_metadata.append(("mh", meta.meta_hash))
            if meta.license_hash is not None:
                nft_metadata.append(("lh", meta.license_hash))
            metadata_program = Program.to(nft_metadata)
            metadata_dict = {
                "program": metadata_program,
                "royalty_pc": request.royalty_percentage,
                "royalty_ph": royalty_puzhash,
            }
            metadata_list.append(metadata_dict)
        target_list = [decode_puzzle_hash(target) for target in request.target_list]
        if request.xch_change_target is not None:
            if request.xch_change_target.startswith("xch"):
                xch_change_ph = decode_puzzle_hash(request.xch_change_target)
            else:
                xch_change_ph = bytes32.from_hexstr(request.xch_change_target)
        else:
            xch_change_ph = None

        if request.mint_from_did:
            await nft_wallet.mint_from_did(
                metadata_list,
                mint_number_start=request.mint_number_start,
                mint_total=request.mint_total,
                target_list=target_list,
                xch_coins=set(request.xch_coins) if request.xch_coins is not None else None,
                xch_change_ph=xch_change_ph,
                new_innerpuzhash=request.new_innerpuzhash,
                new_p2_puzhash=request.new_p2_puzhash,
                did_coin=request.did_coin,
                did_lineage_parent=request.did_lineage_parent,
                fee=request.fee,
                action_scope=action_scope,
                extra_conditions=extra_conditions,
            )
        else:
            await nft_wallet.mint_from_xch(
                metadata_list,
                mint_number_start=request.mint_number_start,
                mint_total=request.mint_total,
                target_list=target_list,
                xch_coins=set(request.xch_coins) if request.xch_coins is not None else None,
                xch_change_ph=xch_change_ph,
                fee=request.fee,
                action_scope=action_scope,
                extra_conditions=extra_conditions,
            )
        async with action_scope.use() as interface:
            sb = WalletSpendBundle.aggregate(
                [tx.spend_bundle for tx in interface.side_effects.transactions if tx.spend_bundle is not None]
                + [sb for sb in interface.side_effects.extra_spends]
            )
        nft_id_list = []
        for cs in sb.coin_spends:
            if cs.coin.puzzle_hash == SINGLETON_LAUNCHER_PUZZLE_HASH:
                nft_id_list.append(encode_puzzle_hash(cs.coin.name(), AddressType.NFT.hrp(self.service.config)))

        # tx_endpoint will take care of the default values here
        return NFTMintBulkResponse(
            [],
            [],
            WalletSpendBundle([], G2Element()),
            nft_id_list,
        )

    async def get_coin_records(self, request: dict[str, Any]) -> EndpointResult:
        parsed_request = GetCoinRecords.from_json_dict(request)

        if parsed_request.limit != uint32.MAXIMUM and parsed_request.limit > self.max_get_coin_records_limit:
            raise ValueError(f"limit of {self.max_get_coin_records_limit} exceeded: {parsed_request.limit}")

        for filter_name, filter in {
            "coin_id_filter": parsed_request.coin_id_filter,
            "puzzle_hash_filter": parsed_request.puzzle_hash_filter,
            "parent_coin_id_filter": parsed_request.parent_coin_id_filter,
            "amount_filter": parsed_request.amount_filter,
        }.items():
            if filter is None:
                continue
            if len(filter.values) > self.max_get_coin_records_filter_items:
                raise ValueError(
                    f"{filter_name} max items {self.max_get_coin_records_filter_items} exceeded: {len(filter.values)}"
                )

        result = await self.service.wallet_state_manager.coin_store.get_coin_records(
            offset=parsed_request.offset,
            limit=parsed_request.limit,
            wallet_id=parsed_request.wallet_id,
            wallet_type=None if parsed_request.wallet_type is None else WalletType(parsed_request.wallet_type),
            coin_type=None if parsed_request.coin_type is None else CoinType(parsed_request.coin_type),
            coin_id_filter=parsed_request.coin_id_filter,
            puzzle_hash_filter=parsed_request.puzzle_hash_filter,
            parent_coin_id_filter=parsed_request.parent_coin_id_filter,
            amount_filter=parsed_request.amount_filter,
            amount_range=parsed_request.amount_range,
            confirmed_range=parsed_request.confirmed_range,
            spent_range=parsed_request.spent_range,
            order=CoinRecordOrder(parsed_request.order),
            reverse=parsed_request.reverse,
            include_total_count=parsed_request.include_total_count,
        )

        return {
            "coin_records": [coin_record.to_json_dict_parsed_metadata() for coin_record in result.records],
            "total_count": result.total_count,
        }

    async def get_farmed_amount(self, request: dict[str, Any]) -> EndpointResult:
        tx_records: list[TransactionRecord] = await self.service.wallet_state_manager.tx_store.get_farming_rewards()
        amount = 0
        pool_reward_amount = 0
        farmer_reward_amount = 0
        fee_amount = 0
        blocks_won = 0
        last_height_farmed = uint32(0)

        include_pool_rewards = request.get("include_pool_rewards", False)

        for record in tx_records:
            if record.wallet_id not in self.service.wallet_state_manager.wallets:
                continue
            if record.type == TransactionType.COINBASE_REWARD.value:
                if (
                    not include_pool_rewards
                    and self.service.wallet_state_manager.wallets[record.wallet_id].type() == WalletType.POOLING_WALLET
                ):
                    # Don't add pool rewards for pool wallets unless explicitly requested
                    continue
                pool_reward_amount += record.amount
            height = record.height_farmed(self.service.constants.GENESIS_CHALLENGE)
            # .get_farming_rewards() above queries for only confirmed records.  This
            # could be hinted by making TransactionRecord generic but streamable can't
            # handle that presently.  Existing code would have raised an exception
            # anyway if this were to fail and we already have an assert below.
            assert height is not None
            if record.type == TransactionType.FEE_REWARD.value:
                base_farmer_reward = calculate_base_farmer_reward(height)
                fee_amount += record.amount - base_farmer_reward
                farmer_reward_amount += base_farmer_reward
                blocks_won += 1
            last_height_farmed = max(last_height_farmed, height)
            amount += record.amount

        last_time_farmed = uint64(
            await self.service.get_timestamp_for_height(last_height_farmed) if last_height_farmed > 0 else 0
        )
        assert amount == pool_reward_amount + farmer_reward_amount + fee_amount
        return {
            "farmed_amount": amount,
            "pool_reward_amount": pool_reward_amount,
            "farmer_reward_amount": farmer_reward_amount,
            "fee_amount": fee_amount,
            "last_height_farmed": last_height_farmed,
            "last_time_farmed": last_time_farmed,
            "blocks_won": blocks_won,
        }

    @tx_endpoint(push=False)
    async def create_signed_transaction(
        self,
        request: dict[str, Any],
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
        hold_lock: bool = True,
    ) -> EndpointResult:
        if "wallet_id" in request:
            wallet_id = uint32(request["wallet_id"])
            wallet = self.service.wallet_state_manager.wallets[wallet_id]
        else:
            wallet = self.service.wallet_state_manager.main_wallet

        assert isinstance(wallet, (Wallet, CATWallet, CRCATWallet)), (
            "create_signed_transaction only works for standard and CAT wallets"
        )

        if "additions" not in request or len(request["additions"]) < 1:
            raise ValueError("Specify additions list")

        additions: list[dict[str, Any]] = request["additions"]
        amount_0: uint64 = uint64(additions[0]["amount"])
        assert amount_0 <= self.service.constants.MAX_COIN_AMOUNT
        puzzle_hash_0 = bytes32.from_hexstr(additions[0]["puzzle_hash"])
        if len(puzzle_hash_0) != 32:
            raise ValueError(f"Address must be 32 bytes. {puzzle_hash_0.hex()}")

        memos_0 = [] if "memos" not in additions[0] else [mem.encode("utf-8") for mem in additions[0]["memos"]]

        additional_outputs: list[CreateCoin] = []
        for addition in additions[1:]:
            receiver_ph = bytes32.from_hexstr(addition["puzzle_hash"])
            if len(receiver_ph) != 32:
                raise ValueError(f"Address must be 32 bytes. {receiver_ph.hex()}")
            amount = uint64(addition["amount"])
            if amount > self.service.constants.MAX_COIN_AMOUNT:
                raise ValueError(f"Coin amount cannot exceed {self.service.constants.MAX_COIN_AMOUNT}")
            memos = [] if "memos" not in addition else [mem.encode("utf-8") for mem in addition["memos"]]
            additional_outputs.append(CreateCoin(receiver_ph, amount, memos))

        fee: uint64 = uint64(request.get("fee", 0))

        coins = None
        if "coins" in request and len(request["coins"]) > 0:
            coins = {Coin.from_json_dict(coin_json) for coin_json in request["coins"]}

        async def _generate_signed_transaction() -> EndpointResult:
            await wallet.generate_signed_transaction(
                [amount_0] + [output.amount for output in additional_outputs],
                [bytes32(puzzle_hash_0)] + [output.puzzle_hash for output in additional_outputs],
                action_scope,
                fee,
                coins=coins,
                memos=[memos_0] + [output.memos if output.memos is not None else [] for output in additional_outputs],
                extra_conditions=(
                    *extra_conditions,
                    *(
                        AssertCoinAnnouncement(
                            asserted_id=bytes32.from_hexstr(ca["coin_id"]),
                            asserted_msg=(
                                hexstr_to_bytes(ca["message"])
                                if request.get("morph_bytes") is None
                                else std_hash(hexstr_to_bytes(ca["morph_bytes"]) + hexstr_to_bytes(ca["message"]))
                            ),
                        )
                        for ca in request.get("coin_announcements", [])
                    ),
                    *(
                        AssertPuzzleAnnouncement(
                            asserted_ph=bytes32.from_hexstr(pa["puzzle_hash"]),
                            asserted_msg=(
                                hexstr_to_bytes(pa["message"])
                                if request.get("morph_bytes") is None
                                else std_hash(hexstr_to_bytes(pa["morph_bytes"]) + hexstr_to_bytes(pa["message"]))
                            ),
                        )
                        for pa in request.get("puzzle_announcements", [])
                    ),
                ),
            )
            # tx_endpoint wrapper will take care of this
            return {"signed_txs": None, "signed_tx": None, "transactions": None}

        if hold_lock:
            async with self.service.wallet_state_manager.lock:
                return await _generate_signed_transaction()
        else:
            return await _generate_signed_transaction()

    ##########################################################################################
    # Pool Wallet
    ##########################################################################################
    @tx_endpoint(push=True)
    @marshal
    async def pw_join_pool(
        self,
        request: PWJoinPool,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> PWJoinPoolResponse:
        wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=PoolWallet)

        pool_wallet_info: PoolWalletInfo = await wallet.get_current_state()
        if (
            pool_wallet_info.current.state == FARMING_TO_POOL.value
            and pool_wallet_info.current.pool_url == request.pool_url
        ):
            raise ValueError(f"Already farming to pool {pool_wallet_info.current.pool_url}")

        owner_pubkey = pool_wallet_info.current.owner_pubkey
        new_target_state: PoolState = create_pool_state(
            FARMING_TO_POOL,
            request.target_puzzlehash,
            owner_pubkey,
            request.pool_url,
            request.relative_lock_height,
        )

        total_fee = await wallet.join_pool(new_target_state, request.fee, action_scope)
        # tx_endpoint will take care of filling in these default values
        return PWJoinPoolResponse(
            [],
            [],
            total_fee=total_fee,
            transaction=REPLACEABLE_TRANSACTION_RECORD,
            fee_transaction=REPLACEABLE_TRANSACTION_RECORD,
        )

    @tx_endpoint(push=True)
    @marshal
    async def pw_self_pool(
        self,
        request: PWSelfPool,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> PWSelfPoolResponse:
        # Leaving a pool requires two state transitions.
        # First we transition to PoolSingletonState.LEAVING_POOL
        # Then we transition to FARMING_TO_POOL or SELF_POOLING
        wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=PoolWallet)

        total_fee = await wallet.self_pool(request.fee, action_scope)
        # tx_endpoint will take care of filling in these default values
        return PWSelfPoolResponse(
            [],
            [],
            total_fee=total_fee,
            transaction=REPLACEABLE_TRANSACTION_RECORD,
            fee_transaction=REPLACEABLE_TRANSACTION_RECORD,
        )

    @tx_endpoint(push=True)
    @marshal
    async def pw_absorb_rewards(
        self,
        request: PWAbsorbRewards,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> PWAbsorbRewardsResponse:
        """Perform a sweep of the p2_singleton rewards controlled by the pool wallet singleton"""
        wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=PoolWallet)

        assert isinstance(wallet, PoolWallet)
        async with self.service.wallet_state_manager.lock:
            await wallet.claim_pool_rewards(request.fee, request.max_spends_in_tx, action_scope)
            state: PoolWalletInfo = await wallet.get_current_state()
            return PWAbsorbRewardsResponse(
                [],
                [],
                state=state,
                transaction=REPLACEABLE_TRANSACTION_RECORD,
                fee_transaction=REPLACEABLE_TRANSACTION_RECORD,
            )

    @marshal
    async def pw_status(self, request: PWStatus) -> PWStatusResponse:
        """Return the complete state of the Pool wallet with id `request["wallet_id"]`"""
        wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=PoolWallet)

        assert isinstance(wallet, PoolWallet)
        state: PoolWalletInfo = await wallet.get_current_state()
        unconfirmed_transactions: list[TransactionRecord] = await wallet.get_unconfirmed_transactions()
        return PWStatusResponse(
            state=state,
            unconfirmed_transactions=unconfirmed_transactions,
        )

    ##########################################################################################
    # DataLayer Wallet
    ##########################################################################################
    @tx_endpoint(push=True)
    @marshal
    async def create_new_dl(
        self,
        request: CreateNewDL,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> CreateNewDLResponse:
        """Initialize the DataLayer Wallet (only one can exist)"""
        if self.service.wallet_state_manager is None:
            raise ValueError("The wallet service is not currently initialized")

        try:
            dl_wallet = self.service.wallet_state_manager.get_dl_wallet()
        except ValueError:
            async with self.service.wallet_state_manager.lock:
                dl_wallet = await DataLayerWallet.create_new_dl_wallet(self.service.wallet_state_manager)

        async with self.service.wallet_state_manager.lock:
            launcher_id = await dl_wallet.generate_new_reporter(
                request.root,
                action_scope,
                fee=request.fee,
                extra_conditions=extra_conditions,
            )

        # tx_endpoint will take care of these default values
        return CreateNewDLResponse([], [], launcher_id=launcher_id)

    @marshal
    async def dl_track_new(self, request: DLTrackNew) -> Empty:
        """Initialize the DataLayer Wallet (only one can exist)"""
        if self.service.wallet_state_manager is None:
            raise ValueError("The wallet service is not currently initialized")
        try:
            dl_wallet = self.service.wallet_state_manager.get_dl_wallet()
        except ValueError:
            async with self.service.wallet_state_manager.lock:
                dl_wallet = await DataLayerWallet.create_new_dl_wallet(
                    self.service.wallet_state_manager,
                )
        peer_list = self.service.get_full_node_peers_in_order()
        peer_length = len(peer_list)
        for i, peer in enumerate(peer_list):
            try:
                await dl_wallet.track_new_launcher_id(
                    request.launcher_id,
                    peer,
                )
            except LauncherCoinNotFoundError as e:
                if i == peer_length - 1:
                    raise e  # raise the error if we've tried all peers
                continue  # try some other peers, maybe someone has it
        return Empty()

    @marshal
    async def dl_stop_tracking(self, request: DLStopTracking) -> Empty:
        """Initialize the DataLayer Wallet (only one can exist)"""
        if self.service.wallet_state_manager is None:
            raise ValueError("The wallet service is not currently initialized")

        dl_wallet = self.service.wallet_state_manager.get_dl_wallet()
        await dl_wallet.stop_tracking_singleton(request.launcher_id)
        return Empty()

    @marshal
    async def dl_latest_singleton(self, request: DLLatestSingleton) -> DLLatestSingletonResponse:
        """Get the singleton record for the latest singleton of a launcher ID"""
        if self.service.wallet_state_manager is None:
            raise ValueError("The wallet service is not currently initialized")

        wallet = self.service.wallet_state_manager.get_dl_wallet()
        record = await wallet.get_latest_singleton(request.launcher_id, request.only_confirmed)
        return DLLatestSingletonResponse(record)

    @marshal
    async def dl_singletons_by_root(self, request: DLSingletonsByRoot) -> DLSingletonsByRootResponse:
        """Get the singleton records that contain the specified root"""
        if self.service.wallet_state_manager is None:
            raise ValueError("The wallet service is not currently initialized")

        wallet = self.service.wallet_state_manager.get_dl_wallet()
        records = await wallet.get_singletons_by_root(request.launcher_id, request.root)
        return DLSingletonsByRootResponse(records)

    @tx_endpoint(push=True)
    @marshal
    async def dl_update_root(
        self,
        request: DLUpdateRoot,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> DLUpdateRootResponse:
        """Get the singleton record for the latest singleton of a launcher ID"""
        if self.service.wallet_state_manager is None:
            raise ValueError("The wallet service is not currently initialized")

        wallet = self.service.wallet_state_manager.get_dl_wallet()
        async with self.service.wallet_state_manager.lock:
            await wallet.create_update_state_spend(
                request.launcher_id,
                request.new_root,
                action_scope,
                fee=request.fee,
                extra_conditions=extra_conditions,
            )

        # tx_endpoint will take care of default values here
        return DLUpdateRootResponse(
            [],
            [],
            REPLACEABLE_TRANSACTION_RECORD,
        )

    @tx_endpoint(push=True)
    @marshal
    async def dl_update_multiple(
        self,
        request: DLUpdateMultiple,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> DLUpdateMultipleResponse:
        """Update multiple singletons with new merkle roots"""
        if self.service.wallet_state_manager is None:
            raise RuntimeError("not initialized")

        wallet = self.service.wallet_state_manager.get_dl_wallet()
        async with self.service.wallet_state_manager.lock:
            # TODO: This method should optionally link the singletons with announcements.
            #       Otherwise spends are vulnerable to signature subtraction.
            # TODO: This method should natively support spending many and attaching one fee
            fee_per_launcher = uint64(request.fee // len(request.updates.launcher_root_pairs))
            for launcher_root_pair in request.updates.launcher_root_pairs:
                await wallet.create_update_state_spend(
                    launcher_root_pair.launcher_id,
                    launcher_root_pair.new_root,
                    action_scope,
                    fee=fee_per_launcher,
                    extra_conditions=extra_conditions,
                )

            # tx_endpoint will take care of default values here
            return DLUpdateMultipleResponse(
                [],
                [],
            )

    @marshal
    async def dl_history(self, request: DLHistory) -> DLHistoryResponse:
        """Get the singleton record for the latest singleton of a launcher ID"""
        if self.service.wallet_state_manager is None:
            raise ValueError("The wallet service is not currently initialized")

        wallet = self.service.wallet_state_manager.get_dl_wallet()
        additional_kwargs = {}

        if request.min_generation is not None:
            additional_kwargs["min_generation"] = uint32(request.min_generation)
        if request.max_generation is not None:
            additional_kwargs["max_generation"] = uint32(request.max_generation)
        if request.num_results is not None:
            additional_kwargs["num_results"] = uint32(request.num_results)

        history = await wallet.get_history(request.launcher_id, **additional_kwargs)
        return DLHistoryResponse(history, uint32(len(history)))

    @marshal
    async def dl_owned_singletons(self, request: Empty) -> DLOwnedSingletonsResponse:
        """Get all owned singleton records"""
        if self.service.wallet_state_manager is None:
            raise ValueError("The wallet service is not currently initialized")

        wallet = self.service.wallet_state_manager.get_dl_wallet()
        singletons = await wallet.get_owned_singletons()

        return DLOwnedSingletonsResponse(singletons, uint32(len(singletons)))

    @marshal
    async def dl_get_mirrors(self, request: DLGetMirrors) -> DLGetMirrorsResponse:
        """Get all of the mirrors for a specific singleton"""
        if self.service.wallet_state_manager is None:
            raise ValueError("The wallet service is not currently initialized")

        wallet = self.service.wallet_state_manager.get_dl_wallet()
        return DLGetMirrorsResponse(await wallet.get_mirrors_for_launcher(request.launcher_id))

    @tx_endpoint(push=True)
    @marshal
    async def dl_new_mirror(
        self,
        request: DLNewMirror,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> DLNewMirrorResponse:
        """Add a new on chain message for a specific singleton"""
        if self.service.wallet_state_manager is None:
            raise ValueError("The wallet service is not currently initialized")

        dl_wallet = self.service.wallet_state_manager.get_dl_wallet()
        async with self.service.wallet_state_manager.lock:
            await dl_wallet.create_new_mirror(
                request.launcher_id,
                request.amount,
                Mirror.encode_urls(request.urls),
                action_scope,
                fee=request.fee,
                extra_conditions=extra_conditions,
            )

        # tx_endpoint will take care of default values here
        return DLNewMirrorResponse(
            [],
            [],
        )

    @tx_endpoint(push=True)
    @marshal
    async def dl_delete_mirror(
        self,
        request: DLDeleteMirror,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> DLDeleteMirrorResponse:
        """Remove an existing mirror for a specific singleton"""
        if self.service.wallet_state_manager is None:
            raise ValueError("The wallet service is not currently initialized")

        dl_wallet = self.service.wallet_state_manager.get_dl_wallet()
        async with self.service.wallet_state_manager.lock:
            await dl_wallet.delete_mirror(
                request.coin_id,
                self.service.get_full_node_peer(),
                action_scope,
                fee=request.fee,
                extra_conditions=extra_conditions,
            )

        # tx_endpoint will take care of default values here
        return DLDeleteMirrorResponse(
            [],
            [],
        )

    @marshal
    async def dl_verify_proof(
        self,
        request: DLProof,
    ) -> VerifyProofResponse:
        """Verify a proof of inclusion for a DL singleton"""
        res = await dl_verify_proof(
            request,
            peer=self.service.get_full_node_peer(),
            wallet_node=self.service.wallet_state_manager.wallet_node,
        )

        return res

    ##########################################################################################
    # Verified Credential
    ##########################################################################################
    @tx_endpoint(push=True)
    @marshal
    async def vc_mint(
        self,
        request: VCMint,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> VCMintResponse:
        """
        Mint a verified credential using the assigned DID
        :param request: We require 'did_id' that will be minting the VC and options for a new 'target_address' as well
        as a 'fee' for the mint tx
        :return: a 'vc_record' containing all the information of the soon-to-be-confirmed vc as well as any relevant
        'transactions'
        """
        did_id = decode_puzzle_hash(request.did_id)
        puzhash: Optional[bytes32] = None
        if request.target_address is not None:
            puzhash = decode_puzzle_hash(request.target_address)

        vc_wallet: VCWallet = await self.service.wallet_state_manager.get_or_create_vc_wallet()
        vc_record = await vc_wallet.launch_new_vc(
            did_id, action_scope, puzhash, request.fee, extra_conditions=extra_conditions
        )
        return VCMintResponse([], [], vc_record)

    @marshal
    async def vc_get(self, request: VCGet) -> VCGetResponse:
        """
        Given a launcher ID get the verified credential
        :param request: the 'vc_id' launcher id of a verifiable credential
        :return: the 'vc_record' representing the specified verifiable credential
        """
        vc_record = await self.service.wallet_state_manager.vc_store.get_vc_record(request.vc_id)
        return VCGetResponse(vc_record)

    @marshal
    async def vc_get_list(self, request: VCGetList) -> VCGetListResponse:
        """
        Get a list of verified credentials
        :param request: optional parameters for pagination 'start' and 'count'
        :return: all 'vc_records' in the specified range and any 'proofs' associated with the roots contained within
        """

        vc_list = await self.service.wallet_state_manager.vc_store.get_vc_record_list(request.start, request.end)
        return VCGetListResponse(
            [VCRecordWithCoinID.from_vc_record(vc) for vc in vc_list],
            [
                VCProofWithHash(
                    rec.vc.proof_hash, None if fetched_proof is None else VCProofsRPC.from_vc_proofs(fetched_proof)
                )
                for rec in vc_list
                if rec.vc.proof_hash is not None
                for fetched_proof in (
                    await self.service.wallet_state_manager.vc_store.get_proofs_for_root(rec.vc.proof_hash),
                )
            ],
        )

    @tx_endpoint(push=True)
    @marshal
    async def vc_spend(
        self,
        request: VCSpend,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> VCSpendResponse:
        """
        Spend a verified credential
        :param request: Required 'vc_id' launcher id of the vc we wish to spend. Optional parameters for a 'new_puzhash'
        for the vc to end up at and 'new_proof_hash' & 'provider_inner_puzhash' which can be used to update the vc's
        proofs. Also standard 'fee' & 'reuse_puzhash' parameters for the transaction.
        :return: a list of all relevant 'transactions' (TransactionRecord) that this spend generates (VC TX + fee TX)
        """

        vc_wallet: VCWallet = await self.service.wallet_state_manager.get_or_create_vc_wallet()

        await vc_wallet.generate_signed_transaction(
            [uint64(1)],
            [
                request.new_puzhash
                if request.new_puzhash is not None
                else await action_scope.get_puzzle_hash(self.service.wallet_state_manager)
            ],
            action_scope,
            request.fee,
            vc_id=request.vc_id,
            new_proof_hash=request.new_proof_hash,
            provider_inner_puzhash=request.provider_inner_puzhash,
            extra_conditions=extra_conditions,
        )

        return VCSpendResponse([], [])  # tx_endpoint takes care of filling this out

    @marshal
    async def vc_add_proofs(self, request: VCAddProofs) -> Empty:
        """
        Add a set of proofs to the DB that can be used when spending a VC. VCs are near useless until their proofs have
        been added.
        :param request: 'proofs' is a dictionary of key/value pairs
        :return:
        """
        vc_wallet: VCWallet = await self.service.wallet_state_manager.get_or_create_vc_wallet()

        await vc_wallet.store.add_vc_proofs(request.to_vc_proofs())

        return Empty()

    @marshal
    async def vc_get_proofs_for_root(self, request: VCGetProofsForRoot) -> VCGetProofsForRootResponse:
        """
        Given a specified vc root, get any proofs associated with that root.
        :param request: must specify 'root' representing the tree hash of some set of proofs
        :return: a dictionary of root hashes mapped to dictionaries of key value pairs of 'proofs'
        """

        vc_wallet: VCWallet = await self.service.wallet_state_manager.get_or_create_vc_wallet()

        vc_proofs: Optional[VCProofs] = await vc_wallet.store.get_proofs_for_root(request.root)
        if vc_proofs is None:
            raise ValueError("no proofs found for specified root")  # pragma: no cover
        return VCGetProofsForRootResponse.from_vc_proofs(vc_proofs)

    @tx_endpoint(push=True)
    @marshal
    async def vc_revoke(
        self,
        request: VCRevoke,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> VCRevokeResponse:
        """
        Revoke an on chain VC provided the correct DID is available
        :param request: required 'vc_parent_id' for the VC coin. Standard transaction params 'fee' & 'reuse_puzhash'.
        :return: a list of all relevant 'transactions' (TransactionRecord) that this spend generates (VC TX + fee TX)
        """

        vc_wallet: VCWallet = await self.service.wallet_state_manager.get_or_create_vc_wallet()

        await vc_wallet.revoke_vc(
            request.vc_parent_id,
            self.service.get_full_node_peer(),
            action_scope,
            request.fee,
            extra_conditions=extra_conditions,
        )

        return VCRevokeResponse([], [])  # tx_endpoint takes care of filling this out

    @tx_endpoint(push=True)
    async def crcat_approve_pending(
        self,
        request: dict[str, Any],
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> EndpointResult:
        """
        Moving any "pending approval" CR-CATs into the spendable balance of the wallet
        :param request: Required 'wallet_id'. Optional 'min_amount_to_claim' (default: full balance).
        Standard transaction params 'fee' & 'reuse_puzhash'.
        :return: a list of all relevant 'transactions' (TransactionRecord) that this spend generates:
        (CRCAT TX + fee TX)
        """

        @streamable
        @dataclasses.dataclass(frozen=True)
        class CRCATApprovePending(Streamable):
            wallet_id: uint32
            min_amount_to_claim: uint64
            fee: uint64 = uint64(0)

        parsed_request = CRCATApprovePending.from_json_dict(request)
        cr_cat_wallet = self.service.wallet_state_manager.wallets[parsed_request.wallet_id]
        assert isinstance(cr_cat_wallet, CRCATWallet)

        await cr_cat_wallet.claim_pending_approval_balance(
            parsed_request.min_amount_to_claim,
            action_scope,
            fee=parsed_request.fee,
            extra_conditions=extra_conditions,
        )

        return {
            "transactions": None,  # tx_endpoint wrapper will take care of this
        }

    @marshal
    async def gather_signing_info(
        self,
        request: GatherSigningInfo,
    ) -> GatherSigningInfoResponse:
        return GatherSigningInfoResponse(await self.service.wallet_state_manager.gather_signing_info(request.spends))

    @marshal
    async def apply_signatures(
        self,
        request: ApplySignatures,
    ) -> ApplySignaturesResponse:
        return ApplySignaturesResponse(
            [await self.service.wallet_state_manager.apply_signatures(request.spends, request.signing_responses)]
        )

    @marshal
    async def submit_transactions(
        self,
        request: SubmitTransactions,
    ) -> SubmitTransactionsResponse:
        return SubmitTransactionsResponse(
            await self.service.wallet_state_manager.submit_transactions(request.signed_transactions)
        )

    @marshal
    async def execute_signing_instructions(
        self,
        request: ExecuteSigningInstructions,
    ) -> ExecuteSigningInstructionsResponse:
        return ExecuteSigningInstructionsResponse(
            await self.service.wallet_state_manager.execute_signing_instructions(
                request.signing_instructions, request.partial_allowed
            )
        )
