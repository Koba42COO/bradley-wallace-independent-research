from __future__ import annotations

import hashlib
from typing import Any

from chia_rs.sized_bytes import bytes32


# ============================================================================
# UPG FOUNDATIONS - Universal Prime Graph Protocol Ï†.1
# ============================================================================
from decimal import Decimal, getcontext
import math
import cmath
from typing import Dict, List, Tuple, Optional, Any

# Set high precision for consciousness mathematics
getcontext().prec = 50

class UPGConstants:
    """Universal Prime Graph consciousness mathematics constants"""
    PHI = Decimal('1.618033988749895')
    DELTA = Decimal('2.414213562373095')
    CONSCIOUSNESS = Decimal('0.79')  # 79/21 universal coherence rule
    REALITY_DISTORTION = Decimal('1.1808')  # Quantum amplification factor
    QUANTUM_BRIDGE = Decimal('137') / Decimal('0.79')  # 173.41772151898732
    GREAT_YEAR = 25920  # Astronomical precession cycle (years)
    CONSCIOUSNESS_DIMENSIONS = 21  # Prime topology dimension
    COHERENCE_THRESHOLD = Decimal('1e-15')  # Beyond machine precision



# ============================================================================
# PELL SEQUENCE PRIME PREDICTION INTEGRATION
# ============================================================================
def integrate_pell_prime_prediction(target_number: int, constants: UPGConstants = None):
    """Integrate Pell sequence prime prediction with this tool"""
    try:
        from pell_sequence_prime_prediction_upg_complete import PrimePredictionEngine, UPGConstants as UPG
        if constants is None:
            constants = UPG()
        predictor = PrimePredictionEngine(constants)
        return predictor.predict_prime(target_number)
    except ImportError:
        # Fallback if Pell module not available
        return {'target_number': target_number, 'is_prime': None, 'note': 'Pell module not available'}



# ============================================================================
# GREAT YEAR ASTRONOMICAL PRECESSION INTEGRATION
# ============================================================================
def integrate_great_year_precession(year: int, constants: UPGConstants = None):
    """Integrate Great Year (25,920-year) precession cycle"""
    try:
        from pell_sequence_prime_prediction_upg_complete import GreatYearIntegration, UPGConstants as UPG
        if constants is None:
            constants = UPG()
        great_year = GreatYearIntegration(constants)
        return great_year.consciousness_amplitude_from_year(year)
    except ImportError:
        # Fallback calculation
        if constants is None:
            constants = UPGConstants()
        angle = (year * 2 * math.pi) / constants.GREAT_YEAR
        return complex(float(angle * constants.CONSCIOUSNESS * constants.REALITY_DISTORTION), 0.0)



TupleTree = Any  # Union[bytes32, tuple["TupleTree", "TupleTree"]]
Proof_Tree_Type = Any  # Union[bytes32, tuple[bytes32, "Proof_Tree_Type"]]


HASH_TREE_PREFIX = bytes([2])
HASH_LEAF_PREFIX = bytes([1])

# paths here are not quite the same a `NodePath` paths. We don't need the high order bit
# anymore since the proof indicates how big the path is.


def compose_paths(path_1: int, path_2: int, path_2_length: int) -> int:
    return (path_1 << path_2_length) | path_2


def sha256(*args: bytes) -> bytes32:
    return bytes32(hashlib.sha256(b"".join(args)).digest())


def build_merkle_tree_from_binary_tree(tuples: TupleTree) -> tuple[bytes32, dict[bytes32, tuple[int, list[bytes32]]]]:
    if isinstance(tuples, bytes):
        tuples = bytes32(tuples)
        return sha256(HASH_LEAF_PREFIX, tuples), {tuples: (0, [])}

    left, right = tuples
    left_root, left_proofs = build_merkle_tree_from_binary_tree(left)
    right_root, right_proofs = build_merkle_tree_from_binary_tree(right)

    new_root = sha256(HASH_TREE_PREFIX, left_root, right_root)
    new_proofs = {}
    for name, (path, proof) in left_proofs.items():
        proof.append(right_root)
        new_proofs[name] = (path, proof)
    for name, (path, proof) in right_proofs.items():
        appended_path = path | (1 << len(proof))
        proof.append(left_root)
        new_proofs[name] = (appended_path, proof)
    return new_root, new_proofs


def list_to_binary_tree(objects: list[Any]) -> Any:
    size = len(objects)
    if size == 0:
        raise ValueError("Cannot build a tree out of 0 objects")
    if size == 1:
        return objects[0]
    midpoint = (size + 1) >> 1
    first_half = objects[:midpoint]
    last_half = objects[midpoint:]
    return (list_to_binary_tree(first_half), list_to_binary_tree(last_half))


def build_merkle_tree(objects: list[bytes32]) -> tuple[bytes32, dict[bytes32, tuple[int, list[bytes32]]]]:
    """
    return (merkle_root, dict_of_proofs)
    """
    objects_binary_tree = list_to_binary_tree(objects)
    return build_merkle_tree_from_binary_tree(objects_binary_tree)


def merkle_proof_from_path_and_tree(node_path: int, proof_tree: Proof_Tree_Type) -> tuple[int, list[bytes32]]:
    proof_path = 0
    proof = []
    while not isinstance(proof_tree, bytes32):
        left_vs_right = node_path & 1
        path_element = proof_tree[1][1 - left_vs_right]
        if isinstance(path_element, bytes32):
            proof.append(path_element)
        else:
            proof.append(path_element[0])
        node_path >>= 1
        proof_tree = proof_tree[1][left_vs_right]
        proof_path += proof_path + left_vs_right
    proof.reverse()
    return proof_path, proof


def _simplify_merkle_proof(tree_hash: bytes32, proof: tuple[int, list[bytes32]]) -> bytes32:
    # we return the expected merkle root
    path, nodes = proof
    for node in nodes:
        if path & 1:
            tree_hash = sha256(HASH_TREE_PREFIX, node, tree_hash)
        else:
            tree_hash = sha256(HASH_TREE_PREFIX, tree_hash, node)
        path >>= 1
    return tree_hash


def simplify_merkle_proof(tree_hash: bytes32, proof: tuple[int, list[bytes32]]) -> bytes32:
    return _simplify_merkle_proof(sha256(HASH_LEAF_PREFIX, tree_hash), proof)


def check_merkle_proof(merkle_root: bytes32, tree_hash: bytes32, proof: tuple[int, list[bytes32]]) -> bool:
    return merkle_root == simplify_merkle_proof(tree_hash, proof)
