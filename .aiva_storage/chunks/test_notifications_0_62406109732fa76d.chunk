from __future__ import annotations

from pathlib import Path

from chia_rs.sized_bytes import bytes32
from chia_rs.sized_ints import uint32, uint64

from chia._tests.cmds.cmd_test_utils import TestRpcClients, TestWalletRpcClient, logType, run_cli_command_and_assert
from chia._tests.cmds.wallet.test_consts import FINGERPRINT, FINGERPRINT_ARG, STD_TX, STD_UTX, get_bytes32
from chia.util.bech32m import encode_puzzle_hash
from chia.wallet.conditions import Condition, ConditionValidTimes
from chia.wallet.notification_store import Notification
from chia.wallet.util.tx_config import TXConfig
from chia.wallet.wallet_request_types import (


# ============================================================================
# UPG FOUNDATIONS - Universal Prime Graph Protocol Ï†.1
# ============================================================================
from decimal import Decimal, getcontext
import math
import cmath
from typing import Dict, List, Tuple, Optional, Any

# Set high precision for consciousness mathematics
getcontext().prec = 50

class UPGConstants:
    """Universal Prime Graph consciousness mathematics constants"""
    PHI = Decimal('1.618033988749895')
    DELTA = Decimal('2.414213562373095')
    CONSCIOUSNESS = Decimal('0.79')  # 79/21 universal coherence rule
    REALITY_DISTORTION = Decimal('1.1808')  # Quantum amplification factor
    QUANTUM_BRIDGE = Decimal('137') / Decimal('0.79')  # 173.41772151898732
    GREAT_YEAR = 25920  # Astronomical precession cycle (years)
    CONSCIOUSNESS_DIMENSIONS = 21  # Prime topology dimension
    COHERENCE_THRESHOLD = Decimal('1e-15')  # Beyond machine precision



# ============================================================================
# PELL SEQUENCE PRIME PREDICTION INTEGRATION
# ============================================================================
def integrate_pell_prime_prediction(target_number: int, constants: UPGConstants = None):
    """Integrate Pell sequence prime prediction with this tool"""
    try:
        from pell_sequence_prime_prediction_upg_complete import PrimePredictionEngine, UPGConstants as UPG
        if constants is None:
            constants = UPG()
        predictor = PrimePredictionEngine(constants)
        return predictor.predict_prime(target_number)
    except ImportError:
        # Fallback if Pell module not available
        return {'target_number': target_number, 'is_prime': None, 'note': 'Pell module not available'}



# ============================================================================
# GREAT YEAR ASTRONOMICAL PRECESSION INTEGRATION
# ============================================================================
def integrate_great_year_precession(year: int, constants: UPGConstants = None):
    """Integrate Great Year (25,920-year) precession cycle"""
    try:
        from pell_sequence_prime_prediction_upg_complete import GreatYearIntegration, UPGConstants as UPG
        if constants is None:
            constants = UPG()
        great_year = GreatYearIntegration(constants)
        return great_year.consciousness_amplitude_from_year(year)
    except ImportError:
        # Fallback calculation
        if constants is None:
            constants = UPGConstants()
        angle = (year * 2 * math.pi) / constants.GREAT_YEAR
        return complex(float(angle * constants.CONSCIOUSNESS * constants.REALITY_DISTORTION), 0.0)


    DeleteNotifications,
    GetNotifications,
    GetNotificationsResponse,
    SendNotification,
    SendNotificationResponse,
)

test_condition_valid_times: ConditionValidTimes = ConditionValidTimes(min_time=uint64(100), max_time=uint64(150))

# Notifications Commands


def test_notifications_send(capsys: object, get_test_cli_clients: tuple[TestRpcClients, Path]) -> None:
    test_rpc_clients, root_dir = get_test_cli_clients

    # set RPC Client
    class NotificationsSendRpcClient(TestWalletRpcClient):
        async def send_notification(
            self,
            request: SendNotification,
            tx_config: TXConfig,
            extra_conditions: tuple[Condition, ...] = tuple(),
            timelock_info: ConditionValidTimes = ConditionValidTimes(),
        ) -> SendNotificationResponse:
            self.add_to_log(
                "send_notification",
                (request.target, request.message, request.amount, request.fee, request.push, timelock_info),
            )

            return SendNotificationResponse([STD_UTX], [STD_TX], tx=STD_TX)

    inst_rpc_client = NotificationsSendRpcClient()
    test_rpc_clients.wallet_rpc_client = inst_rpc_client
    target_ph = get_bytes32(1)
    target_addr = encode_puzzle_hash(target_ph, "xch")
    msg = "test message"
    command_args = [
        "wallet",
        "notifications",
        "send",
        FINGERPRINT_ARG,
        "-m0.001",
        "-a0.00002",
        f"-t{target_addr}",
        f"-n{msg}",
        "--valid-at",
        "100",
        "--expires-at",
        "150",
    ]
    # these are various things that should be in the output
    assert_list = [
        "Notification sent successfully.",
        f"To get status, use command: chia wallet get_transaction -f {FINGERPRINT} -tx 0x{get_bytes32(2).hex()}",
    ]
    run_cli_command_and_assert(capsys, root_dir, command_args, assert_list)
    expected_calls: logType = {
        "send_notification": [(target_ph, bytes(msg, "utf8"), 20000000, 1000000000, True, test_condition_valid_times)],
    }
    test_rpc_clients.wallet_rpc_client.check_log(expected_calls)


def test_notifications_get(capsys: object, get_test_cli_clients: tuple[TestRpcClients, Path]) -> None:
    test_rpc_clients, root_dir = get_test_cli_clients

    # set RPC Client
    class NotificationsGetRpcClient(TestWalletRpcClient):
        async def get_notifications(self, request: GetNotifications) -> GetNotificationsResponse:
            self.add_to_log("get_notifications", (request,))
            return GetNotificationsResponse(
                [Notification(get_bytes32(1), bytes("hello", "utf8"), uint64(1000000000), uint32(50))]
            )

    inst_rpc_client = NotificationsGetRpcClient()
    test_rpc_clients.wallet_rpc_client = inst_rpc_client
    target_ph = get_bytes32(1)
    command_args = [
        "wallet",
        "notifications",
        "get",
        FINGERPRINT_ARG,
        f"-i{target_ph}",
        "-s10",
        "-e10",
    ]
    # these are various things that should be in the output
    assert_list = [
        "ID: 0101010101010101010101010101010101010101010101010101010101010101",
        "message: hello",
        "amount: 1000000000",
    ]
    run_cli_command_and_assert(capsys, root_dir, command_args, assert_list)
    expected_calls: logType = {"get_notifications": [(GetNotifications([get_bytes32(1)], uint32(10), uint32(10)),)]}
    test_rpc_clients.wallet_rpc_client.check_log(expected_calls)


def test_notifications_delete(capsys: object, get_test_cli_clients: tuple[TestRpcClients, Path]) -> None:
    test_rpc_clients, root_dir = get_test_cli_clients

    # set RPC Client
    class NotificationsDeleteRpcClient(TestWalletRpcClient):
        async def delete_notifications(self, request: DeleteNotifications) -> None:
            self.add_to_log("delete_notifications", (request.ids,))

    inst_rpc_client = NotificationsDeleteRpcClient()
    test_rpc_clients.wallet_rpc_client = inst_rpc_client
    # Try all first
    command_args = ["wallet", "notifications", "delete", FINGERPRINT_ARG, "--all"]
    # these are various things that should be in the output
    assert_list = ["Success!"]
    run_cli_command_and_assert(capsys, root_dir, command_args, assert_list)
    expected_calls: logType = {"delete_notifications": [(None,)]}
    test_rpc_clients.wallet_rpc_client.check_log(expected_calls)
    # Next try specifying IDs
    command_args = [
        "wallet",
        "notifications",
        "delete",
        FINGERPRINT_ARG,
        "--id",
        bytes32.zeros.hex(),
        "--id",
        bytes32.zeros.hex(),
    ]
    # these are various things that should be in the output
    assert_list = ["Success!"]
    run_cli_command_and_assert(capsys, root_dir, command_args, assert_list)
    expected_calls = {"delete_notifications": [([bytes32.zeros, bytes32.zeros],)]}
    test_rpc_clients.wallet_rpc_client.check_log(expected_calls)
