  # fail
    if clear_cache:
        b.clean_block_records()
    with pytest.raises(AssertionError):
        await b.lookup_block_generators(blocks_2[600].prev_header_hash, {uint32(3)})

    if clear_cache:
        b.clean_block_records()
    with pytest.raises(AssertionError):
        await b.lookup_block_generators(blocks_1[600].prev_header_hash, {uint32(3)})


async def get_fork_info(blockchain: Blockchain, block: FullBlock, peak: BlockRecord) -> ForkInfo:
    fork_chain, fork_hash = await lookup_fork_chain(
        blockchain,
        (peak.height, peak.header_hash),
        (block.height - 1, block.prev_header_hash),
        blockchain.constants,
    )
    # now we know how long the fork is, and can compute the fork
    # height.
    fork_height = block.height - len(fork_chain) - 1
    fork_info = ForkInfo(fork_height, fork_height, fork_hash)

    # now run all the blocks of the fork to compute the additions
    # and removals. They are recorded in the fork_info object
    counter = 0
    start = time.monotonic()
    for height in range(fork_info.fork_height + 1, block.height):
        fork_block: Optional[FullBlock] = await blockchain.block_store.get_full_block(fork_chain[uint32(height)])
        assert fork_block is not None
        assert fork_block.height - 1 == fork_info.peak_height
        assert fork_block.height == 0 or fork_block.prev_header_hash == fork_info.peak_hash
        await blockchain.run_single_block(fork_block, fork_info)
        counter += 1
    end = time.monotonic()
    log.info(
        f"executed {counter} block generators in {end - start:2f} s. "
        f"{len(fork_info.additions_since_fork)} additions, "
        f"{len(fork_info.removals_since_fork)} removals"
    )

    return fork_info


@pytest.mark.anyio
async def test_get_header_blocks_in_range_tx_filter_non_tx_block(empty_blockchain: Blockchain, bt: BlockTools) -> None:
    """
    Covers the case of calling `get_header_blocks_in_range`, requesting
    transactions filter, on a non transaction block.
    """
    b = empty_blockchain
    blocks = bt.get_consecutive_blocks(2)
    for block in blocks:
        await _validate_and_add_block(b, block)
    non_tx_block = next(block for block in blocks if not block.is_transaction_block())
    blocks_with_filter = await b.get_header_blocks_in_range(0, 42, tx_filter=True)
    empty_tx_filter = b"\x00"
    assert blocks_with_filter[non_tx_block.header_hash].transactions_filter == empty_tx_filter


@dataclass(frozen=True)
class ForkInfoTestSetup:
    fork_info: ForkInfo
    initial_additions_since_fork: dict[bytes32, ForkAdd]
    test_block: FullBlock
    coin: Coin
    child_coin: Coin

    @classmethod
    def create(cls, same_ph_as_parent: bool, same_amount_as_parent: bool) -> ForkInfoTestSetup:
        from chia._tests.util.network_protocol_data import full_block as test_block

        unrelated_coin = Coin(bytes32([0] * 32), bytes32([1] * 32), uint64(42))
        # We add this initial state with an unrelated addition, to create a
        # difference between the `rollback` state and the completely empty
        # `reset` state.
        initial_additions_since_fork = {
            unrelated_coin.name(): ForkAdd(
                coin=unrelated_coin,
                confirmed_height=uint32(1),
                timestamp=uint64(0),
                hint=None,
                is_coinbase=False,
                same_as_parent=False,
            )
        }
        fork_info = ForkInfo(
            test_block.height - 1,
            test_block.height - 1,
            test_block.prev_header_hash,
            additions_since_fork=copy.copy(initial_additions_since_fork),
        )
        puzzle_hash = bytes32([2] * 32)
        amount = uint64(1337)
        coin = Coin(bytes32([3] * 32), puzzle_hash, amount)
        child_coin_ph = puzzle_hash if same_ph_as_parent else bytes32([4] * 32)
        child_coin_amount = amount if same_amount_as_parent else uint64(0)
        child_coin = Coin(coin.name(), child_coin_ph, child_coin_amount)
        return cls(
            fork_info=fork_info,
            initial_additions_since_fork=initial_additions_since_fork,
            test_block=test_block,
            coin=coin,
            child_coin=child_coin,
        )

    def check_additions(self, expected_same_parent_additions: set[bytes32]) -> None:
        assert all(
            a in self.fork_info.additions_since_fork and self.fork_info.additions_since_fork[a].same_as_parent
            for a in expected_same_parent_additions
        )
        remaining_additions = set(self.fork_info.additions_since_fork) - expected_same_parent_additions
        assert not any(self.fork_info.additions_since_fork[a].same_as_parent for a in remaining_additions)


@pytest.mark.parametrize("same_ph_as_parent", [True, False])
@pytest.mark.parametrize("same_amount_as_parent", [True, False])
@pytest.mark.parametrize("rollback", [True, False])
@pytest.mark.parametrize("reset", [True, False])
@pytest.mark.anyio
async def test_include_spends_same_as_parent(
    same_ph_as_parent: bool, same_amount_as_parent: bool, rollback: bool, reset: bool
) -> None:
    """
    Tests that `ForkInfo` properly tracks same-as-parent created coins.
    A created coin is tracked as such if its puzzle hash and amount match the
    parent. We're covering here `include_spends`, `rollback` and `reset` in the
    context of same-as-parent coins.
    """
    test_setup = ForkInfoTestSetup.create(same_ph_as_parent, same_amount_as_parent)
    # Now let's prepare the test spend bundle conditions
    create_coin = [(test_setup.child_coin.puzzle_hash, test_setup.child_coin.amount, None)]
    conds = SpendBundleConditions(
        [
            SpendConditions(
                test_setup.coin.name(),
                test_setup.coin.parent_coin_info,
                test_setup.coin.puzzle_hash,
                test_setup.coin.amount,
                None,
                None,
                None,
                None,
                None,
                None,
                create_coin,
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                0,
                0,
                0,
                b"",
            )
        ],
        0,
        0,
        0,
        None,
        None,
        [],
        0,
        0,
        0,
        True,
        0,
        0,
        0,
        0,
        0,
    )
    # Now let's run the test
    test_setup.fork_info.include_spends(conds, test_setup.test_block, test_setup.test_block.header_hash)
    # Let's make sure the results are as expected
    expected_same_parent_additions = (
        {test_setup.child_coin.name()} if same_ph_as_parent and same_amount_as_parent else set()
    )
    test_setup.check_additions(expected_same_parent_additions)
    if rollback:
        # Now we rollback before the spend that belongs to the test conditions
        test_setup.fork_info.rollback(test_setup.test_block.prev_header_hash, test_setup.test_block.height - 1)
        # That should leave only the initial additions we started with, which
        # are unrelated to the test conditions. We added this initial state to
        # create a difference between `rollback` state and the completely empty
        # `reset` state.
        assert test_setup.fork_info.additions_since_fork == test_setup.initial_additions_since_fork
    if reset:
        # Now we reset to a test height and header hash
        test_setup.fork_info.reset(1, bytes32([0] * 32))
        # That should leave this empty
        assert test_setup.fork_info.additions_since_fork == {}


@pytest.mark.parametrize("same_ph_as_parent", [True, False])
@pytest.mark.parametrize("same_amount_as_parent", [True, False])
@pytest.mark.parametrize("rollback", [True, False])
@pytest.mark.parametrize("reset", [True, False])
@pytest.mark.anyio
async def test_include_block_same_as_parent_coins(
    same_ph_as_parent: bool, same_amount_as_parent: bool, rollback: bool, reset: bool
) -> None:
    """
    Tests that `ForkInfo` properly tracks same-as-parent created coins.
    A created coin is tracked as such if its puzzle hash and amount match the
    parent. We're covering here `include_block`, `rollback` and `reset` in the
    context of such coins.
    """
    test_setup = ForkInfoTestSetup.create(same_ph_as_parent, same_amount_as_parent)
    # Now let's run the test
    test_setup.fork_info.include_block(
        [(test_setup.child_coin, None)],
        [(test_setup.coin.name(), test_setup.coin)],
        test_setup.test_block,
        test_setup.test_block.header_hash,
    )
    # Let's make sure the results are as expected
    expected_same_as_parent_additions = (
        {test_setup.child_coin.name()} if same_ph_as_parent and same_amount_as_parent else set()
    )
    test_setup.check_additions(expected_same_as_parent_additions)
    if rollback:
        # Now we rollback before the spend that belongs to the test conditions
        test_setup.fork_info.rollback(test_setup.test_block.prev_header_hash, test_setup.test_block.height - 1)
        # That should leave only the initial additions we started with
        assert test_setup.fork_info.additions_since_fork == test_setup.initial_additions_since_fork
    if reset:
        # Now we reset to a test height and header hash
        test_setup.fork_info.reset(1, bytes32([0] * 32))
        # That should leave this empty
        assert test_setup.fork_info.additions_since_fork == {}
