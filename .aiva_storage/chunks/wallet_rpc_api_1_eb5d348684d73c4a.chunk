et_state_manager.wallets:
            raise ValueError(f"Wallet with ID {request.wallet_id} does not exist")
        wallet = self.service.wallet_state_manager.wallets[request.wallet_id]
        if not isinstance(wallet, (Wallet, CATWallet)):
            raise ValueError("Cannot split coins from non-fungible wallet types")

        outputs = [
            CreateCoin(
                await action_scope.get_puzzle_hash(
                    self.service.wallet_state_manager, override_reuse_puzhash_with=False
                ),
                request.amount_per_coin,
            )
            for _ in range(request.number_of_coins)
        ]
        if len(outputs) == 0:
            return SplitCoinsResponse([], [])

        if wallet.type() == WalletType.STANDARD_WALLET and coin.amount < total_amount + request.fee:
            async with action_scope.use() as interface:
                interface.side_effects.selected_coins.append(coin)
            coins = await wallet.select_coins(
                uint64(total_amount + request.fee - coin.amount),
                action_scope,
            )
            coins.add(coin)
        else:
            coins = {coin}

        await wallet.generate_signed_transaction(
            [output.amount for output in outputs],
            [output.puzzle_hash for output in outputs],
            action_scope,
            request.fee,
            coins=coins,
            extra_conditions=extra_conditions,
        )

        return SplitCoinsResponse([], [])  # tx_endpoint will take care to fill this out

    @tx_endpoint(push=False)
    @marshal
    async def combine_coins(
        self, request: CombineCoins, action_scope: WalletActionScope, extra_conditions: tuple[Condition, ...] = tuple()
    ) -> CombineCoinsResponse:
        # Some "number of coins" validation
        if request.number_of_coins > request.coin_num_limit:
            raise ValueError(
                f"{request.number_of_coins} coins is greater then the maximum limit of {request.coin_num_limit} coins."
            )
        if request.number_of_coins < 1:
            raise ValueError("You need at least two coins to combine")
        if len(request.target_coin_ids) > request.number_of_coins:
            raise ValueError("More coin IDs specified than desired number of coins to combine")

        if request.wallet_id not in self.service.wallet_state_manager.wallets:
            raise ValueError(f"Wallet with ID {request.wallet_id} does not exist")
        wallet = self.service.wallet_state_manager.wallets[request.wallet_id]
        if not isinstance(wallet, (Wallet, CATWallet)):
            raise ValueError("Cannot combine coins from non-fungible wallet types")

        coins: list[Coin] = []

        # First get the coin IDs specified
        if request.target_coin_ids != []:
            coins.extend(
                cr.coin
                for cr in (
                    await self.service.wallet_state_manager.coin_store.get_coin_records(
                        wallet_id=request.wallet_id,
                        coin_id_filter=HashFilter(request.target_coin_ids, mode=uint8(FilterMode.include.value)),
                    )
                ).records
            )

        async with action_scope.use() as interface:
            interface.side_effects.selected_coins.extend(coins)

        # Next let's select enough coins to meet the target + fee if there is one
        fungible_amount_needed = uint64(0) if request.target_coin_amount is None else request.target_coin_amount
        if isinstance(wallet, Wallet):
            fungible_amount_needed = uint64(fungible_amount_needed + request.fee)
        amount_selected = sum(c.amount for c in coins)
        if amount_selected < fungible_amount_needed:  # implicit fungible_amount_needed > 0 here
            coins.extend(
                await wallet.select_coins(
                    amount=uint64(fungible_amount_needed - amount_selected), action_scope=action_scope
                )
            )

        if len(coins) > request.number_of_coins:
            raise ValueError(
                f"Options specified cannot be met without selecting more coins than specified: {len(coins)}"
            )

        # Now let's select enough coins to get to the target number to combine
        if len(coins) < request.number_of_coins:
            async with action_scope.use() as interface:
                coins.extend(
                    cr.coin
                    for cr in (
                        await self.service.wallet_state_manager.coin_store.get_coin_records(
                            wallet_id=request.wallet_id,
                            limit=uint32(request.number_of_coins - len(coins)),
                            order=CoinRecordOrder.amount,
                            coin_id_filter=HashFilter(
                                [c.name() for c in interface.side_effects.selected_coins],
                                mode=uint8(FilterMode.exclude.value),
                            ),
                            reverse=request.largest_first,
                        )
                    ).records
                )

        async with action_scope.use() as interface:
            interface.side_effects.selected_coins.extend(coins)

        primary_output_amount = (
            uint64(sum(c.amount for c in coins)) if request.target_coin_amount is None else request.target_coin_amount
        )
        if isinstance(wallet, Wallet):
            primary_output_amount = uint64(primary_output_amount - request.fee)

        await wallet.generate_signed_transaction(
            [primary_output_amount],
            [await action_scope.get_puzzle_hash(self.service.wallet_state_manager)],
            action_scope,
            request.fee,
            coins=set(coins),
            extra_conditions=extra_conditions,
        )

        return CombineCoinsResponse([], [])  # tx_endpoint will take care to fill this out

    @marshal
    async def get_transactions(self, request: GetTransactions) -> GetTransactionsResponse:
        to_puzzle_hash: Optional[bytes32] = None
        if request.to_address is not None:
            to_puzzle_hash = decode_puzzle_hash(request.to_address)

        transactions = await self.service.wallet_state_manager.tx_store.get_transactions_between(
            wallet_id=request.wallet_id,
            start=uint16(0) if request.start is None else request.start,
            end=uint16(50) if request.end is None else request.end,
            sort_key=request.sort_key,
            reverse=request.reverse,
            to_puzzle_hash=to_puzzle_hash,
            type_filter=request.type_filter,
            confirmed=request.confirmed,
        )
        tx_list = []
        # Format for clawback transactions
        for tr in transactions:
            tx = (await self._convert_tx_puzzle_hash(tr)).to_json_dict()
            tx_list.append(tx)
            if tx["type"] not in CLAWBACK_INCOMING_TRANSACTION_TYPES:
                continue
            coin: Coin = tr.additions[0]
            record: Optional[WalletCoinRecord] = await self.service.wallet_state_manager.coin_store.get_coin_record(
                coin.name()
            )
            if record is None:
                log.error(f"Cannot find coin record for type {tx['type']} transaction {tx['name']}")
                continue
            try:
                tx["metadata"] = record.parsed_metadata().to_json_dict()
            except ValueError as e:
                log.error(f"Could not parse coin record metadata: {type(e).__name__} {e}")
                continue
            tx["metadata"]["coin_id"] = coin.name().hex()
            tx["metadata"]["spent"] = record.spent
        return GetTransactionsResponse(
            transactions=[TransactionRecordWithMetadata.from_json_dict(tx) for tx in tx_list],
            wallet_id=request.wallet_id,
        )

    @marshal
    async def get_transaction_count(self, request: GetTransactionCount) -> GetTransactionCountResponse:
        count = await self.service.wallet_state_manager.tx_store.get_transaction_count_for_wallet(
            request.wallet_id, confirmed=request.confirmed, type_filter=request.type_filter
        )
        return GetTransactionCountResponse(
            request.wallet_id,
            uint16(count),
        )

    @marshal
    async def get_next_address(self, request: GetNextAddress) -> GetNextAddressResponse:
        """
        Returns a new address
        """
        wallet = self.service.wallet_state_manager.wallets[request.wallet_id]
        selected = self.service.config["selected_network"]
        prefix = self.service.config["network_overrides"]["config"][selected]["address_prefix"]
        if wallet.type() in {WalletType.STANDARD_WALLET, WalletType.CAT, WalletType.CRCAT, WalletType.RCAT}:
            async with self.service.wallet_state_manager.new_action_scope(
                DEFAULT_TX_CONFIG, push=request.save_derivations
            ) as action_scope:
                raw_puzzle_hash = await action_scope.get_puzzle_hash(
                    self.service.wallet_state_manager, override_reuse_puzhash_with=not request.new_address
                )
            address = encode_puzzle_hash(raw_puzzle_hash, prefix)
        else:
            raise ValueError(f"Wallet type {wallet.type()} cannot create puzzle hashes")

        return GetNextAddressResponse(
            request.wallet_id,
            address,
        )

    @tx_endpoint(push=True)
    @marshal
    async def send_transaction(
        self,
        request: SendTransaction,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> SendTransactionResponse:
        wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=Wallet)

        # TODO: Add support for multiple puzhash/amount/memo sets
        selected_network = self.service.config["selected_network"]
        expected_prefix = self.service.config["network_overrides"]["config"][selected_network]["address_prefix"]
        if request.address[0 : len(expected_prefix)] != expected_prefix:
            raise ValueError("Unexpected Address Prefix")

        await wallet.generate_signed_transaction(
            [request.amount],
            [decode_puzzle_hash(request.address)],
            action_scope,
            request.fee,
            memos=[[mem.encode("utf-8") for mem in request.memos]],
            puzzle_decorator_override=[request.puzzle_decorator[0].to_json_dict()]
            if request.puzzle_decorator is not None
            else None,
            extra_conditions=extra_conditions,
        )

        # Transaction may not have been included in the mempool yet. Use get_transaction to check.
        # tx_endpoint will take care of the default values here
        return SendTransactionResponse([], [], transaction=REPLACEABLE_TRANSACTION_RECORD, transaction_id=bytes32.zeros)

    async def send_transaction_multi(self, request: dict[str, Any]) -> EndpointResult:
        if await self.service.wallet_state_manager.synced() is False:
            raise ValueError("Wallet needs to be fully synced before sending transactions")

        # This is required because this is a "@tx_endpoint" that calls other @tx_endpoints
        request.setdefault("push", True)
        request.setdefault("merge_spends", True)

        wallet_id = uint32(request["wallet_id"])
        wallet = self.service.wallet_state_manager.wallets[wallet_id]

        async with self.service.wallet_state_manager.lock:
            if wallet.type() in {WalletType.CAT, WalletType.CRCAT, WalletType.RCAT}:
                assert isinstance(wallet, CATWallet)
                response = await self.cat_spend(request, hold_lock=False)
                transaction = response["transaction"]
                transactions = response["transactions"]
            else:
                response = await self.create_signed_transaction(request, hold_lock=False)
                transaction = response["signed_tx"]
                transactions = response["transactions"]

        # Transaction may not have been included in the mempool yet. Use get_transaction to check.
        return {
            "transaction": transaction,
            "transaction_id": TransactionRecord.from_json_dict(transaction).name,
            "transactions": transactions,
            "unsigned_transactions": response["unsigned_transactions"],
        }

    @tx_endpoint(push=True, merge_spends=False)
    @marshal
    async def spend_clawback_coins(
        self,
        request: SpendClawbackCoins,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> SpendClawbackCoinsResponse:
        """Spend clawback coins that were sent (to claw them back) or received (to claim them).

        :param coin_ids: list of coin ids to be spent
        :param batch_size: number of coins to spend per bundle
        :param fee: transaction fee in mojos
        :return:
        """
        # Get inner puzzle
        coin_records = await self.service.wallet_state_manager.coin_store.get_coin_records(
            coin_id_filter=HashFilter.include(request.coin_ids),
            coin_type=CoinType.CLAWBACK,
            wallet_type=WalletType.STANDARD_WALLET,
            spent_range=UInt32Range(stop=uint32(0)),
        )

        coins: dict[Coin, ClawbackMetadata] = {}
        batch_size = (
            request.batch_size
            if request.batch_size is not None
            else self.service.wallet_state_manager.config.get("auto_claim", {}).get("batch_size", 50)
        )
        for coin_id, coin_record in coin_records.coin_id_to_record.items():
            try:
                metadata = coin_record.parsed_metadata()
                assert isinstance(metadata, ClawbackMetadata)
                coins[coin_record.coin] = metadata
                if len(coins) >= batch_size:
                    await self.service.wallet_state_manager.spend_clawback_coins(
                        coins,
                        request.fee,
                        action_scope,
                        request.force,
                        extra_conditions=extra_conditions,
                    )
                    coins = {}
            except Exception as e:
                log.error(f"Failed to spend clawback coin {coin_id.hex()}: %s", e)
        if len(coins) > 0:
            await self.service.wallet_state_manager.spend_clawback_coins(
                coins,
                request.fee,
                action_scope,
                request.force,
                extra_conditions=extra_conditions,
            )

        # tx_endpoint will fill in the default values here
        return SpendClawbackCoinsResponse([], [], transaction_ids=[])

    @marshal
    async def delete_unconfirmed_transactions(self, request: DeleteUnconfirmedTransactions) -> Empty:
        if request.wallet_id not in self.service.wallet_state_manager.wallets:
            raise ValueError(f"Wallet id {request.wallet_id} does not exist")
        if await self.service.wallet_state_manager.synced() is False:
            raise ValueError("Wallet needs to be fully synced.")

        async with self.service.wallet_state_manager.db_wrapper.writer():
            await self.service.wallet_state_manager.tx_store.delete_unconfirmed_transactions(request.wallet_id)
            wallet = self.service.wallet_state_manager.wallets[request.wallet_id]
            if wallet.type() == WalletType.POOLING_WALLET.value:
                assert isinstance(wallet, PoolWallet)
                wallet.target_state = None
            return Empty()

    @marshal
    async def select_coins(
        self,
        request: SelectCoins,
    ) -> SelectCoinsResponse:
        assert self.service.logged_in_fingerprint is not None

        # Some backwards compat fill-ins
        if request.excluded_coin_ids is None:
            if request.exclude_coins is not None:
                request = request.override(
                    excluded_coin_ids=[c.name() for c in request.exclude_coins],
                    exclude_coins=None,
                )

        # don't love this snippet of code
        # but I think action scopes need to accept CoinSelectionConfigs
        # instead of solely TXConfigs in order for this to be less ugly
        autofilled_cs_config = request.autofill(
            constants=self.service.wallet_state_manager.constants,
        )
        tx_config = DEFAULT_TX_CONFIG.override(
            **{
                field.name: getattr(autofilled_cs_config, field.name)
                for field in dataclasses.fields(autofilled_cs_config)
            }
        )

        if await self.service.wallet_state_manager.synced() is False:
            raise ValueError("Wallet needs to be fully synced before selecting coins")

        wallet = self.service.wallet_state_manager.wallets[request.wallet_id]
        async with self.service.wallet_state_manager.new_action_scope(tx_config, push=False) as action_scope:
            selected_coins = await wallet.select_coins(request.amount, action_scope)

        return SelectCoinsResponse(coins=list(selected_coins))

    @marshal
    async def get_spendable_coins(self, request: GetSpendableCoins) -> GetSpendableCoinsResponse:
        if await self.service.wallet_state_manager.synced() is False:
            raise ValueError("Wallet needs to be fully synced before getting all coins")

        state_mgr = self.service.wallet_state_manager
        wallet = state_mgr.wallets[request.wallet_id]
        async with state_mgr.lock:
            all_coin_records = await state_mgr.coin_store.get_unspent_coins_for_wallet(request.wallet_id)
            if wallet.type() in {WalletType.CAT, WalletType.CRCAT, WalletType.RCAT}:
                assert isinstance(wallet, CATWallet)
                spendable_coins: list[WalletCoinRecord] = await wallet.get_cat_spendable_coins(all_coin_records)
            else:
                spendable_coins = list(
                    await state_mgr.get_spendable_coins_for_wallet(request.wallet_id, all_coin_records)
                )

            # Now we get the unconfirmed transactions and manually derive the additions and removals.
            unconfirmed_transactions: list[TransactionRecord] = await state_mgr.tx_store.get_unconfirmed_for_wallet(
                request.wallet_id
            )
            unconfirmed_removal_ids: dict[bytes32, uint64] = {
                coin.name(): transaction.created_at_time
                for transaction in unconfirmed_transactions
                for coin in transaction.removals
            }
            unconfirmed_additions: list[Coin] = [
                coin
                for transaction in unconfirmed_transactions
                for coin in transaction.additions
                if await state_mgr.does_coin_belong_to_wallet(coin, request.wallet_id)
            ]
            valid_spendable_cr: list[CoinRecord] = []
            unconfirmed_removals: list[CoinRecord] = []
            for coin_record in all_coin_records:
                if coin_record.name() in unconfirmed_removal_ids:
                    unconfirmed_removals.append(coin_record.to_coin_record(unconfirmed_removal_ids[coin_record.name()]))

            cs_config = request.autofill(constants=self.service.wallet_state_manager.constants)
            for coin_record in spendable_coins:  # remove all the unconfirmed coins, exclude coins and dust.
                if coin_record.name() in unconfirmed_removal_ids:
                    continue
                if coin_record.coin.name() in cs_config.excluded_coin_ids:
                    continue
                if (coin_record.coin.amount < cs_config.min_coin_amount) or (
                    coin_record.coin.amount > cs_config.max_coin_amount
                ):
                    continue
                if coin_record.coin.amount in cs_config.excluded_coin_amounts:
                    continue
                c_r = await state_mgr.get_coin_record_by_wallet_record(coin_record)
                assert c_r is not None and c_r.coin == coin_record.coin  # this should never happen
                valid_spendable_cr.append(c_r)

        return GetSpendableCoinsResponse(
            confirmed_records=valid_spendable_cr,
            unconfirmed_removals=unconfirmed_removals,
            unconfirmed_additions=unconfirmed_additions,
        )

    @marshal
    async def get_coin_records_by_names(self, request: GetCoinRecordsByNames) -> GetCoinRecordsByNamesResponse:
        if await self.service.wallet_state_manager.synced() is False:
            raise ValueError("Wallet needs to be fully synced before finding coin information")

        kwargs: dict[str, Any] = {
            "coin_id_filter": HashFilter.include(request.names),
        }

        confirmed_range = UInt32Range()
        if request.start_height is not None:
            confirmed_range = dataclasses.replace(confirmed_range, start=request.start_height)
        if request.end_height is not None:
            confirmed_range = dataclasses.replace(confirmed_range, stop=request.end_height)
        if confirmed_range != UInt32Range():
            kwargs["confirmed_range"] = confirmed_range

        if not request.include_spent_coins:
            kwargs["spent_range"] = unspent_range

        async with self.service.wallet_state_manager.lock:
            coin_records: list[CoinRecord] = await self.service.wallet_state_manager.get_coin_records_by_coin_ids(
                **kwargs
            )
            missed_coins: list[str] = [
                "0x" + c_id.hex() for c_id in request.names if c_id not in [cr.name for cr in coin_records]
            ]
            if missed_coins:
                raise ValueError(f"Coin ID's: {missed_coins} not found.")

        return GetCoinRecordsByNamesResponse(coin_records)

    @marshal
    async def get_current_derivation_index(self, request: Empty) -> GetCurrentDerivationIndexResponse:
        assert self.service.wallet_state_manager is not None

        index: Optional[uint32] = await self.service.wallet_state_manager.puzzle_store.get_last_derivation_path()

        return GetCurrentDerivationIndexResponse(index)

    @marshal
    async def extend_derivation_index(self, request: ExtendDerivationIndex) -> ExtendDerivationIndexResponse:
        assert self.service.wallet_state_manager is not None

        # Require that the wallet is fully synced
        synced = await self.service.wallet_state_manager.synced()
        if synced is False:
            raise ValueError("Wallet needs to be fully synced before extending derivation index")

        current: Optional[uint32] = await self.service.wallet_state_manager.puzzle_store.get_last_derivation_path()

        # Additional sanity check that the wallet is synced
        if current is None:
            raise ValueError("No current derivation record found, unable to extend index")

        # Require that the new index is greater than the current index
        if request.index <= current:
            raise ValueError(f"New derivation index must be greater than current index: {current}")

        if request.index - current > MAX_DERIVATION_INDEX_DELTA:
            raise ValueError(
                "Too many derivations requested. "
                f"Use a derivation index less than {current + MAX_DERIVATION_INDEX_DELTA + 1}"
            )

        # Since we've bumping the derivation index without having found any new puzzles, we want
        # to preserve the current last used index, so we call create_more_puzzle_hashes with
        # mark_existing_as_used=False
        result = await self.service.wallet_state_manager.create_more_puzzle_hashes(
            from_zero=False, mark_existing_as_used=False, up_to_index=request.index, num_additional_phs=0
        )
        await result.commit(self.service.wallet_state_manager)

        updated_index = await self.service.wallet_state_manager.puzzle_store.get_last_derivation_path()

        return ExtendDerivationIndexResponse(updated_index)

    @marshal
    async def get_notifications(self, request: GetNotifications) -> GetNotificationsResponse:
        if request.ids is None:
            notifications: list[
                Notification
            ] = await self.service.wallet_state_manager.notification_manager.notification_store.get_all_notifications(
                pagination=(request.start, request.end)
            )
        else:
            notifications = (
                await self.service.wallet_state_manager.notification_manager.notification_store.get_notifications(
                    request.ids
                )
            )

        return GetNotificationsResponse(notifications)

    @marshal
    async def delete_notifications(self, request: DeleteNotifications) -> Empty:
        if request.ids is None:
            await self.service.wallet_state_manager.notification_manager.notification_store.delete_all_notifications()
        else:
            await self.service.wallet_state_manager.notification_manager.notification_store.delete_notifications(
                request.ids
            )

        return Empty()

    @tx_endpoint(push=True)
    @marshal
    async def send_notification(
        self,
        request: SendNotification,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> SendNotificationResponse:
        await self.service.wallet_state_manager.notification_manager.send_new_notification(
            request.target,
            request.message,
            request.amount,
            action_scope,
            request.fee,
            extra_conditions=extra_conditions,
        )

        # tx_endpoint will take care of these default values
        return SendNotificationResponse([], [], tx=REPLACEABLE_TRANSACTION_RECORD)

    @marshal
    async def verify_signature(self, request: VerifySignature) -> VerifySignatureResponse:
        """
        Given a public key, message and signature, verify if it is valid.
        :param request:
        :return:
        """
        # Default to BLS_MESSAGE_AUGMENTATION_HEX_INPUT as this RPC was originally designed to verify
        # signatures made by `chia keys sign`, which uses BLS_MESSAGE_AUGMENTATION_HEX_INPUT
        if request.signing_mode is None:
            signing_mode = SigningMode.BLS_MESSAGE_AUGMENTATION_HEX_INPUT
        else:
            try:
                signing_mode = SigningMode(request.signing_mode)
            except ValueError:
                raise ValueError(f"Invalid signing mode: {request.signing_mode!r}")

        if signing_mode in {SigningMode.CHIP_0002, SigningMode.CHIP_0002_P2_DELEGATED_CONDITIONS}:
            # CHIP-0002 message signatures are made over the tree hash of:
            #   ("Chia Signed Message", message)
            message_to_verify: bytes = Program.to((CHIP_0002_SIGN_MESSAGE_PREFIX, request.message)).get_tree_hash()
        elif signing_mode == SigningMode.BLS_MESSAGE_AUGMENTATION_HEX_INPUT:
            # Message is expected to be a hex string
            message_to_verify = hexstr_to_bytes(request.message)
        elif signing_mode == SigningMode.BLS_MESSAGE_AUGMENTATION_UTF8_INPUT:
            # Message is expected to be a UTF-8 string
            message_to_verify = bytes(request.message, "utf-8")
        else:
            raise ValueError(f"Unsupported signing mode: {request.signing_mode!r}")

        # Verify using the BLS message augmentation scheme
        is_valid = AugSchemeMPL.verify(
            request.pubkey,
            message_to_verify,
            request.signature,
        )
        if request.address is not None:
            # For signatures made by the sign_message_by_address/sign_message_by_id
            # endpoints, the "address" field should contain the p2_address of the NFT/DID
            # that was used to sign the message.
            puzzle_hash: bytes32 = decode_puzzle_hash(request.address)
            expected_puzzle_hash: Optional[bytes32] = None
            if signing_mode == SigningMode.CHIP_0002_P2_DELEGATED_CONDITIONS:
                puzzle = p2_delegated_conditions.puzzle_for_pk(Program.to(request.pubkey))
                expected_puzzle_hash = bytes32(puzzle.get_tree_hash())
            else:
                expected_puzzle_hash = puzzle_hash_for_synthetic_public_key(request.pubkey)
            if puzzle_hash != expected_puzzle_hash:
                return VerifySignatureResponse(isValid=False, error="Public key doesn't match the address")
        if is_valid:
            return VerifySignatureResponse(isValid=is_valid)
        else:
            return VerifySignatureResponse(isValid=False, error="Signature is invalid.")

    @marshal
    async def sign_message_by_address(self, request: SignMessageByAddress) -> SignMessageByAddressResponse:
        """
        Given a derived P2 address, sign the message by its private key.
        :param request:
        :return:
        """
        puzzle_hash: bytes32 = decode_puzzle_hash(request.address)
        mode: SigningMode = SigningMode.CHIP_0002
        if request.is_hex and request.safe_mode:
            mode = SigningMode.CHIP_0002_HEX_INPUT
        elif not request.is_hex and not request.safe_mode:
            mode = SigningMode.BLS_MESSAGE_AUGMENTATION_UTF8_INPUT
        elif request.is_hex and not request.safe_mode:
            mode = SigningMode.BLS_MESSAGE_AUGMENTATION_HEX_INPUT
        pubkey, signature = await self.service.wallet_state_manager.main_wallet.sign_message(
            request.message, puzzle_hash, mode
        )
        return SignMessageByAddressResponse(
            pubkey=pubkey,
            signature=signature,
            signing_mode=mode.value,
        )

    @marshal
    async def sign_message_by_id(self, request: SignMessageByID) -> SignMessageByIDResponse:
        """
        Given a NFT/DID ID, sign the message by the P2 private key.
        :param request:
        :return:
        """
        entity_id: bytes32 = decode_puzzle_hash(request.id)
        selected_wallet: Optional[WalletProtocol[Any]] = None
        mode: SigningMode = SigningMode.CHIP_0002
        if request.is_hex and request.safe_mode:
            mode = SigningMode.CHIP_0002_HEX_INPUT
        elif not request.is_hex and not request.safe_mode:
            mode = SigningMode.BLS_MESSAGE_AUGMENTATION_UTF8_INPUT
        elif request.is_hex and not request.safe_mode:
            mode = SigningMode.BLS_MESSAGE_AUGMENTATION_HEX_INPUT
        if is_valid_address(request.id, {AddressType.DID}, self.service.config):
            for wallet in self.service.wallet_state_manager.wallets.values():
                if wallet.type() == WalletType.DECENTRALIZED_ID.value:
                    assert isinstance(wallet, DIDWallet)
                    assert wallet.did_info.origin_coin is not None
                    if wallet.did_info.origin_coin.name() == entity_id:
                        selected_wallet = wallet
                        break
            if selected_wallet is None:
                raise ValueError(f"DID for {entity_id.hex()} doesn't exist.")
            assert isinstance(selected_wallet, DIDWallet)
            pubkey, signature = await selected_wallet.sign_message(request.message, mode)
            latest_coin_id = (await selected_wallet.get_coin()).name()
        elif is_valid_address(request.id, {AddressType.NFT}, self.service.config):
            target_nft: Optional[NFTCoinInfo] = None
            for wallet in self.service.wallet_state_manager.wallets.values():
                if wallet.type() == WalletType.NFT.value:
                    assert isinstance(wallet, NFTWallet)
                    nft: Optional[NFTCoinInfo] = await wallet.get_nft(entity_id)
                    if nft is not None:
                        selected_wallet = wallet
                        target_nft = nft
                        break
            if selected_wallet is None or target_nft is None:
                raise ValueError(f"NFT for {entity_id.hex()} doesn't exist.")

            assert isinstance(selected_wallet, NFTWallet)
            pubkey, signature = await selected_wallet.sign_message(request.message, target_nft, mode)
            latest_coin_id = target_nft.coin.name()
        else:
            raise ValueError(f"Unknown ID type, {request.id}")

        return SignMessageByIDResponse(
            pubkey=pubkey,
            signature=signature,
            latest_coin_id=latest_coin_id,
            signing_mode=mode.value,
        )

    ##########################################################################################
    # CATs and Trading
    ##########################################################################################

    @marshal
    async def get_cat_list(self, request: Empty) -> GetCATListResponse:
        return GetCATListResponse([DefaultCAT.from_json_dict(default_cat) for default_cat in DEFAULT_CATS.values()])

    @marshal
    async def cat_set_name(self, request: CATSetName) -> CATSetNameResponse:
        wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=CATWallet)
        await wallet.set_name(request.name)
        return CATSetNameResponse(wallet_id=request.wallet_id)

    @marshal
    async def cat_get_name(self, request: CATGetName) -> CATGetNameResponse:
        wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=CATWallet)
        name: str = wallet.get_name()
        return CATGetNameResponse(wallet_id=request.wallet_id, name=name)

    @marshal
    async def get_stray_cats(self, request: Empty) -> GetStrayCATsResponse:
        """
        Get a list of all unacknowledged CATs
        :param request: RPC request
        :return: A list of unacknowledged CATs
        """
        cats = await self.service.wallet_state_manager.interested_store.get_unacknowledged_tokens()
        return GetStrayCATsResponse(stray_cats=[StrayCAT.from_json_dict(cat) for cat in cats])

    @tx_endpoint(push=True)
    @marshal
    async def cat_spend(
        self,
        request: CATSpend,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
        hold_lock: bool = True,
    ) -> CATSpendResponse:
        wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=CATWallet)

        amounts: list[uint64] = []
        puzzle_hashes: list[bytes32] = []
        memos: list[list[bytes]] = []
        if request.additions is not None:
            for addition in request.additions:
                if addition.amount > self.service.constants.MAX_COIN_AMOUNT:
                    raise ValueError(f"Coin amount cannot exceed {self.service.constants.MAX_COIN_AMOUNT}")
                amounts.append(addition.amount)
                puzzle_hashes.append(addition.puzzle_hash)
                if addition.memos is not None:
                    memos.append([mem.encode("utf-8") for mem in addition.memos])
        else:
            # Our __post_init__ guards against these not being None
            amounts.append(request.amount)  # type: ignore[arg-type]
            puzzle_hashes.append(decode_puzzle_hash(request.inner_address))  # type: ignore[arg-type]
            if request.memos is not None:
                memos.append([mem.encode("utf-8") for mem in request.memos])
        coins: Optional[set[Coin]] = None
        if request.coins is not None and len(request.coins) > 0:
            coins = set(request.coins)

        if hold_lock:
            async with self.service.wallet_state_manager.lock:
                await wallet.generate_signed_transaction(
                    amounts,
                    puzzle_hashes,
                    action_scope,
                    request.fee,
                    cat_discrepancy=request.cat_discrepancy,
                    coins=coins,
                    memos=memos if memos else None,
                    extra_conditions=extra_conditions,
                )
        else:
            await wallet.generate_signed_transaction(
                amounts,
                puzzle_hashes,
                action_scope,
                request.fee,
                cat_discrepancy=request.cat_discrepancy,
                coins=coins,
                memos=memos if memos else None,
                extra_conditions=extra_conditions,
            )

        # tx_endpoint will fill in these default values
        return CATSpendResponse([], [], transaction=REPLACEABLE_TRANSACTION_RECORD, transaction_id=bytes32.zeros)

    @marshal
    async def cat_get_asset_id(self, request: CATGetAssetID) -> CATGetAssetIDResponse:
        wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=CATWallet)
        asset_id: str = wallet.get_asset_id()
        return CATGetAssetIDResponse(asset_id=bytes32.from_hexstr(asset_id), wallet_id=request.wallet_id)

    @marshal
    async def cat_asset_id_to_name(self, request: CATAssetIDToName) -> CATAssetIDToNameResponse:
        wallet = await self.service.wallet_state_manager.get_wallet_for_asset_id(request.asset_id.hex())
        if wallet is None:
            if request.asset_id.hex() in DEFAULT_CATS:
                return CATAssetIDToNameResponse(wallet_id=None, name=DEFAULT_CATS[request.asset_id.hex()]["name"])
            else:
                return CATAssetIDToNameResponse(wallet_id=None, name=None)
        else:
            return CATAssetIDToNameResponse(wallet_id=wallet.id(), name=wallet.get_name())

    @tx_endpoint(push=False)
    @marshal
    async def create_offer_for_ids(
        self,
        request: CreateOfferForIDs,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> CreateOfferForIDsResponse:
        if action_scope.config.push:
            raise ValueError("Cannot push an incomplete spend")

        # This driver_dict construction is to maintain backward compatibility where everything is assumed to be a CAT
        driver_dict: dict[bytes32, PuzzleInfo] = {}
        if request.driver_dict is None:
            for key, amount in request.offer_spec.items():
                if amount > 0 and isinstance(key, bytes32):
                    driver_dict[key] = PuzzleInfo({"type": AssetType.CAT.value, "tail": "0x" + key.hex()})
        else:
            driver_dict = request.driver_dict

        async with self.service.wallet_state_manager.lock:
            result = await self.service.wallet_state_manager.trade_manager.create_offer_for_ids(
                request.offer_spec,
                action_scope,
                driver_dict,
                solver=request.solver,
                fee=request.fee,
                validate_only=request.validate_only,
                extra_conditions=extra_conditions,
            )

        return CreateOfferForIDsResponse(
            [],
            [],
            offer=Offer.from_bytes(result[1].offer),
            trade_record=result[1],
        )

    @marshal
    async def get_offer_summary(self, request: GetOfferSummary) -> GetOfferSummaryResponse:
        dl_summary = None
        if not request.advanced:
            dl_summary = await self.service.wallet_state_manager.trade_manager.get_dl_offer_summary(
                request.parsed_offer
            )
        if dl_summary is not None:
            response = GetOfferSummaryResponse(
                data_layer_summary=dl_summary,
                id=request.parsed_offer.name(),
            )
        else:
            offered, requested, infos, valid_times = request.parsed_offer.summary()
            response = GetOfferSummaryResponse(
                summary=OfferSummary(
                    offered=offered,
                    requested=requested,
                    fees=uint64(request.parsed_offer.fees()),
                    infos=infos,
                    additions=[c.name() for c in request.parsed_offer.additions()],
                    removals=[c.name() for c in request.parsed_offer.removals()],
                    valid_times=valid_times.only_absolutes(),
                ),
                id=request.parsed_offer.name(),
            )

        # This is a bit of a hack in favor of returning some more manageable information about CR-CATs
        # A more general solution surely exists, but I'm not sure what it is right now
        return dataclasses.replace(
            response,
            summary=dataclasses.replace(
                response.summary,
                infos={
                    key: (
                        PuzzleInfo(
                            {
                                **info.info,
                                "also": {
                                    **info.info["also"],
                                    "flags": ProofsChecker.from_program(
                                        uncurry_puzzle(Program(assemble(info.info["also"]["proofs_checker"])))
                                    ).flags,
                                },
                            }
                        )
                        if "also" in info.info and "proofs_checker" in info.info["also"]
                        else info
                    )
                    for key, info in response.summary.infos.items()
                },
            )
            if response.summary is not None
            else None,
        )

    @marshal
    async def check_offer_validity(self, request: CheckOfferValidity) -> CheckOfferValidityResponse:
        offer = Offer.from_bech32(request.offer)
        peer = self.service.get_full_node_peer()
        return CheckOfferValidityResponse(
            valid=(await self.service.wallet_state_manager.trade_manager.check_offer_validity(offer, peer)),
            id=offer.name(),
        )

    @tx_endpoint(push=True)
    async def take_offer(
        self,
        request: dict[str, Any],
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> EndpointResult:
        offer_hex: str = request["offer"]

        offer = Offer.from_bech32(offer_hex)
        fee: uint64 = uint64(request.get("fee", 0))
        maybe_marshalled_solver: Optional[dict[str, Any]] = request.get("solver")
        solver: Optional[Solver]
        if maybe_marshalled_solver is None:
            solver = None
        else:
            solver = Solver(info=maybe_marshalled_solver)

        peer = self.service.get_full_node_peer()
        trade_record = await self.service.wallet_state_manager.trade_manager.respond_to_offer(
            offer,
            peer,
            action_scope,
            fee=fee,
            solver=solver,
            extra_conditions=extra_conditions,
        )

        async with action_scope.use() as interface:
            interface.side_effects.signing_responses.append(
                SigningResponse(bytes(offer._bundle.aggregated_signature), trade_record.trade_id)
            )

        return {
            "trade_record": trade_record.to_json_dict_convenience(),
            "offer": Offer.from_bytes(trade_record.offer).to_bech32(),
            "transactions": None,  # tx_endpoint wrapper will take care of this
            "signing_responses": None,  # tx_endpoint wrapper will take care of this
        }

    async def get_offer(self, request: dict[str, Any]) -> EndpointResult:
        trade_mgr = self.service.wallet_state_manager.trade_manager

        trade_id = bytes32.from_hexstr(request["trade_id"])
        file_contents: bool = request.get("file_contents", False)
        trade_record: Optional[TradeRecord] = await trade_mgr.get_trade_by_id(bytes32(trade_id))
        if trade_record is None:
            raise ValueError(f"No trade with trade id: {trade_id.hex()}")

        offer_to_return: bytes = trade_record.offer if trade_record.taken_offer is None else trade_record.taken_offer
        offer_value: Optional[str] = Offer.from_bytes(offer_to_return).to_bech32() if file_contents else None
        return {"trade_record": trade_record.to_json_dict_convenience(), "offer": offer_value}

    async def get_all_offers(self, request: dict[str, Any]) -> EndpointResult:
        trade_mgr = self.service.wallet_state_manager.trade_manager

        start: int = request.get("start", 0)
        end: int = request.get("end", 10)
        exclude_my_offers: bool = request.get("exclude_my_offers", False)
        exclude_taken_offers: bool = request.get("exclude_taken_offers", False)
        include_completed: bool = request.get("include_completed", False)
        sort_key: Optional[str] = request.get("sort_key", None)
        reverse: bool = request.get("reverse", False)
        file_contents: bool = request.get("file_contents", False)

        all_trades = await trade_mgr.trade_store.get_trades_between(
            start,
            end,
            sort_key=sort_key,
            reverse=reverse,
            exclude_my_offers=exclude_my_offers,
            exclude_taken_offers=exclude_taken_offers,
            include_completed=include_completed,
        )
        result = []
        offer_values: Optional[list[str]] = [] if file_contents else None
        for trade in all_trades:
            result.append(trade.to_json_dict_convenience())
            if file_contents and offer_values is not None:
                offer_to_return: bytes = trade.offer if trade.taken_offer is None else trade.taken_offer
                offer_values.append(Offer.from_bytes(offer_to_return).to_bech32())

        return {"trade_records": result, "offers": offer_values}

    @marshal
    async def get_offers_count(self, request: Empty) -> GetOffersCountResponse:
        trade_mgr = self.service.wallet_state_manager.trade_manager

        (total, my_offers_count, taken_offers_count) = await trade_mgr.trade_store.get_trades_count()

        return GetOffersCountResponse(
            total=uint16(total), my_offers_count=uint16(my_offers_count), taken_offers_count=uint16(taken_offers_count)
        )

    @tx_endpoint(push=True)
    async def cancel_offer(
        self,
        request: dict[str, Any],
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> EndpointResult:
        wsm = self.service.wallet_state_manager
        secure = request["secure"]
        trade_id = bytes32.from_hexstr(request["trade_id"])
        fee: uint64 = uint64(request.get("fee", 0))
        async with self.service.wallet_state_manager.lock:
            await wsm.trade_manager.cancel_pending_offers(
                [trade_id], action_scope, fee=fee, secure=secure, extra_conditions=extra_conditions
            )

        return {"transactions": None}  # tx_endpoint wrapper will take care of this

    @tx_endpoint(push=True, merge_spends=False)
    async def cancel_offers(
        self,
        request: dict[str, Any],
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> EndpointResult:
        secure = request["secure"]
        batch_fee: uint64 = uint64(request.get("batch_fee", 0))
        batch_size = request.get("batch_size", 5)
        cancel_all = request.get("cancel_all", False)
        if cancel_all:
            asset_id = None
        else:
            asset_id = request.get("asset_id", "xch")

        start: int = 0
        end: int = start + batch_size
        trade_mgr = self.service.wallet_state_manager.trade_manager
        log.info(f"Start cancelling offers for  {'asset_id: ' + asset_id if asset_id is not None else 'all'} ...")
        # Traverse offers page by page
        key = None
        if asset_id is not None and asset_id != "xch":
            key = bytes32.from_hexstr(asset_id)
        while True:
            records: dict[bytes32, TradeRecord] = {}
            trades = await trade_mgr.trade_store.get_trades_between(
                start,
                end,
                reverse=True,
                exclude_my_offers=False,
                exclude_taken_offers=True,
                include_completed=False,
            )
            for trade in trades:
                if cancel_all:
                    records[trade.trade_id] = trade
                    continue
                if trade.offer and trade.offer != b"":
                    offer = Offer.from_bytes(trade.offer)
                    if key in offer.arbitrage():
                        records[trade.trade_id] = trade
                        continue

            if len(records) == 0:
                break

            async with self.service.wallet_state_manager.lock:
                await trade_mgr.cancel_pending_offers(
                    list(records.keys()),
                    action_scope,
                    batch_fee,
                    secure,
                    records,
                    extra_conditions=extra_conditions,
                )

            log.info(f"Cancelled offers {start} to {end} ...")
            # If fewer records were returned than requested, we're done
            if len(trades) < batch_size:
                break
            start = end
            end += batch_size

        return {"transactions": None}  # tx_endpoint wrapper will take care of this

    ##########################################################################################
    # Distributed Identities
    ##########################################################################################

    @marshal
    async def did_set_wallet_name(self, request: DIDSetWalletName) -> DIDSetWalletNameResponse:
        wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=DIDWallet)
        await wallet.set_name(request.name)
        return DIDSetWalletNameResponse(request.wallet_id)

    @marshal
    async def did_get_wallet_name(self, request: DIDGetWalletName) -> DIDGetWalletNameResponse:
        wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=DIDWallet)
        return DIDGetWalletNameResponse(request.wallet_id, wallet.get_name())

    @tx_endpoint(push=False)
    @marshal
    async def did_message_spend(
        self,
        request: DIDMessageSpend,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> DIDMessageSpendResponse:
        wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=DIDWallet)

        await wallet.create_message_spend(
            action_scope,
            extra_conditions=(
                *extra_conditions,
                *(CreateCoinAnnouncement(ca) for ca in request.coin_announcements),
                *(CreatePuzzleAnnouncement(pa) for pa in request.puzzle_announcements),
            ),
        )

        # tx_endpoint will take care of the default values here
        return DIDMessageSpendResponse([], [], WalletSpendBundle([], G2Element()))

    @marshal
    async def did_get_info(self, request: DIDGetInfo) -> DIDGetInfoResponse:
        if request.coin_id.startswith(AddressType.DID.hrp(self.service.config)):
            coin_id = decode_puzzle_hash(request.coin_id)
        else:
            coin_id = bytes32.from_hexstr(request.coin_id)
        # Get coin state
        peer = self.service.get_full_node_peer()
        coin_spend, coin_state = await self.get_latest_singleton_coin_spend(peer, coin_id, request.latest)
        uncurried = uncurry_puzzle(coin_spend.puzzle_reveal)
        curried_args = match_did_puzzle(uncurried.mod, uncurried.args)
        if curried_args is None:
            raise ValueError("The coin is not a DID.")
        p2_puzzle, recovery_list_hash, num_verification, singleton_struct, metadata = curried_args
        recovery_list_hash_bytes = recovery_list_hash.as_atom()
        launcher_id = bytes32(singleton_struct.rest().first().as_atom())
        uncurried_p2 = uncurry_puzzle(p2_puzzle)
        (public_key,) = uncurried_p2.args.as_iter()
        memos = compute_memos(WalletSpendBundle([coin_spend], G2Element()))
        hints = []
        coin_memos = memos.get(coin_state.coin.name())
        if coin_memos is not None:
            for memo in coin_memos:
                hints.append(memo)
        return DIDGetInfoResponse(
            did_id=encode_puzzle_hash(launcher_id, AddressType.DID.hrp(self.service.config)),
            latest_coin=coin_state.coin.name(),
            p2_address=encode_puzzle_hash(p2_puzzle.get_tree_hash(), AddressType.XCH.hrp(self.service.config)),
            public_key=public_key.as_atom(),
            recovery_list_hash=bytes32(recovery_list_hash_bytes) if recovery_list_hash_bytes != b"" else None,
            num_verification=uint16(num_verification.as_int()),
            metadata=did_program_to_metadata(metadata),
            launcher_id=launcher_id,
            full_puzzle=Program.from_serialized(coin_spend.puzzle_reveal),
            solution=Program.from_serialized(coin_spend.solution),
            hints=hints,
        )

    @marshal
    async def did_find_lost_did(self, request: DIDFindLostDID) -> DIDFindLostDIDResponse:
        """
        Recover a missing or unspendable DID wallet by a coin id of the DID
        :param coin_id: It can be DID ID, launcher coin ID or any coin ID of the DID you want to find.
        The latest coin ID will take less time.
        :return:
        """
        # Check if we have a DID wallet for this
        if request.coin_id.startswith(AddressType.DID.hrp(self.service.config)):
            coin_id = decode_puzzle_hash(request.coin_id)
        else:
            coin_id = bytes32.from_hexstr(request.coin_id)
        # Get coin state
        peer = self.service.get_full_node_peer()
        coin_spend, coin_state = await self.get_latest_singleton_coin_spend(peer, coin_id)
        uncurried = uncurry_puzzle(coin_spend.puzzle_reveal)
        curried_args = match_did_puzzle(uncurried.mod, uncurried.args)
        if curried_args is None:
            raise ValueError("The coin is not a DID.")
        p2_puzzle, recovery_list_hash, num_verification, singleton_struct, metadata = curried_args
        num_verification_int: Optional[uint16] = uint16(num_verification.as_int())
        assert num_verification_int is not None
        did_data: DIDCoinData = DIDCoinData(
            p2_puzzle,
            bytes32(recovery_list_hash.as_atom()) if recovery_list_hash != Program.NIL else None,
            num_verification_int,
            singleton_struct,
            metadata,
            get_inner_puzzle_from_singleton(coin_spend.puzzle_reveal),
            coin_state,
        )
        hinted_coins, _ = compute_spend_hints_and_additions(coin_spend)
        # Hint is required, if it doesn't have any hint then it should be invalid
        hint: Optional[bytes32] = None
        for hinted_coin in hinted_coins.values():
            if hinted_coin.coin.amount % 2 == 1 and hinted_coin.hint is not None:
                hint = hinted_coin.hint
                break
        derivation_record = None
        if hint is not None:
            derivation_record = (
                await self.service.wallet_state_manager.puzzle_store.get_derivation_record_for_puzzle_hash(hint)
            )
        if derivation_record is None:
            # This is an invalid DID, check if we are owner
            derivation_record = (
                await self.service.wallet_state_manager.puzzle_store.get_derivation_record_for_puzzle_hash(
                    p2_puzzle.get_tree_hash()
                )
            )

        launcher_id = bytes32(singleton_struct.rest().first().as_atom())
        if derivation_record is None:
            raise ValueError(f"This DID {launcher_id} does not belong to the connected wallet")
        else:
            our_inner_puzzle: Program = self.service.wallet_state_manager.main_wallet.puzzle_for_pk(
                derivation_record.pubkey
            )
            did_puzzle = DID_INNERPUZ_MOD.curry(
                our_inner_puzzle, recovery_list_hash, num_verification, singleton_struct, metadata
            )
            full_puzzle = create_singleton_puzzle(did_puzzle, launcher_id)
            did_puzzle_empty_recovery = DID_INNERPUZ_MOD.curry(
                our_inner_puzzle, NIL_TREEHASH, uint64(0), singleton_struct, metadata
            )
            # Check if we have the DID wallet
            did_wallet: Optional[DIDWallet] = None
            for wallet in self.service.wallet_state_manager.wallets.values():
                if isinstance(wallet, DIDWallet):
                    assert wallet.did_info.origin_coin is not None
                    if wallet.did_info.origin_coin.name() == launcher_id:
                        did_wallet = wallet
                        break

            full_puzzle_empty_recovery = create_singleton_puzzle(did_puzzle_empty_recovery, launcher_id)
            if full_puzzle.get_tree_hash() != coin_state.coin.puzzle_hash:
                # It's unclear whether this path is ever reached, and there is no coverage in the DID wallet tests
                if full_puzzle_empty_recovery.get_tree_hash() == coin_state.coin.puzzle_hash:
                    did_puzzle = did_puzzle_empty_recovery
                elif (
                    did_wallet is not None
                    and did_wallet.did_info.current_inner is not None
                    and create_singleton_puzzle(did_wallet.did_info.current_inner, launcher_id).get_tree_hash()
                    == coin_state.coin.puzzle_hash
                ):
                    # Check if the old wallet has the inner puzzle
                    did_puzzle = did_wallet.did_info.current_inner
                else:
                    # Try override
                    if request.recovery_list_hash is not None:
                        recovery_list_hash = Program.from_bytes(request.recovery_list_hash)
                    if request.num_verification is not None:
                        num_verification_int = request.num_verification
                    if request.metadata is not None:
                        metadata = metadata_to_program(request.metadata)
                    did_puzzle = DID_INNERPUZ_MOD.curry(
                        our_inner_puzzle, recovery_list_hash, num_verification, singleton_struct, metadata
                    )
                    full_puzzle = create_singleton_puzzle(did_puzzle, launcher_id)
                    matched = True
                    if full_puzzle.get_tree_hash() != coin_state.coin.puzzle_hash:
                        matched = False
                        # Brute force addresses
                        index = 0
                        derivation_record = await self.service.wallet_state_manager.puzzle_store.get_derivation_record(
                            uint32(index), uint32(1), False
                        )
                        while derivation_record is not None:
                            our_inner_puzzle = self.service.wallet_state_manager.main_wallet.puzzle_for_pk(
                                derivation_record.pubkey
                            )
                            did_puzzle = DID_INNERPUZ_MOD.curry(
                                our_inner_puzzle, recovery_list_hash, num_verification, singleton_struct, metadata
                            )
                            full_puzzle = create_singleton_puzzle(did_puzzle, launcher_id)
                            if full_puzzle.get_tree_hash() == coin_state.coin.puzzle_hash:
                                matched = True
                                break
                            index += 1
                            derivation_record = (
                                await self.service.wallet_state_manager.puzzle_store.get_derivation_record(
                                    uint32(index), uint32(1), False
                                )
                            )

                    if not matched:
                        raise RuntimeError(
                            f"Cannot recover DID {launcher_id} "
                            f"because the last spend updated recovery_list_hash/num_verification/metadata."
                        )

            if did_wallet is None:
                # Create DID wallet
                response: list[CoinState] = await self.service.get_coin_state([launcher_id], peer=peer)
                if len(response) == 0:
                    raise ValueError(f"Could not find the launch coin with ID: {launcher_id}")
                launcher_coin: CoinState = response[0]
                did_wallet = await DIDWallet.create_new_did_wallet_from_coin_spend(
                    self.service.wallet_state_manager,
                    self.service.wallet_state_manager.main_wallet,
                    launcher_coin.coin,
                    did_puzzle,
                    coin_spend,
                    f"DID {encode_puzzle_hash(launcher_id, AddressType.DID.hrp(self.service.config))}",
                )
            else:
                assert did_wallet.did_info.current_inner is not None
                if did_wallet.did_info.current_inner.get_tree_hash() != did_puzzle.get_tree_hash():
                    # Inner DID puzzle doesn't match, we need to update the DID info
                    full_solution: Program = Program.from_bytes(bytes(coin_spend.solution))
                    inner_solution: Program = full_solution.rest().rest().first()
                    recovery_list: list[bytes32] = []
                    backup_required: int = num_verification.as_int()
                    if not did_recovery_is_nil(recovery_list_hash):
                        try:
                            for did in inner_solution.rest().rest().rest().rest().rest().as_python():
                                recovery_list.append(did[0])
                        except Exception:
                            # We cannot recover the recovery list, but it's okay to leave it blank
                            pass
                    did_info: DIDInfo = DIDInfo(
                        did_wallet.did_info.origin_coin,
                        recovery_list,
                        uint64(backup_required),
                        [],
                        did_puzzle,
                        None,
                        None,
                        None,
                        False,
                        json.dumps(did_wallet_puzzles.did_program_to_metadata(metadata)),
                    )
                    await did_wallet.save_info(did_info)
                    await self.service.wallet_state_manager.update_wallet_puzzle_hashes(did_wallet.wallet_info.id)

            try:
                coin = await did_wallet.get_coin()
                if coin.name() == coin_state.coin.name():
                    return DIDFindLostDIDResponse(coin.name())
            except RuntimeError:
                # We don't have any coin for this wallet, add the coin
                pass

            wallet_id = did_wallet.id()
            wallet_type = did_wallet.type()
            assert coin_state.created_height is not None
            coin_record: WalletCoinRecord = WalletCoinRecord(
                coin_state.coin, uint32(coin_state.created_height), uint32(0), False, False, wallet_type, wallet_id
            )
            await self.service.wallet_state_manager.coin_store.add_coin_record(coin_record, coin_state.coin.name())
            await did_wallet.coin_added(
                coin_state.coin,
                uint32(coin_state.created_height),
                peer,
                did_data,
            )
            return DIDFindLostDIDResponse(coin_state.coin.name())

    @tx_endpoint(push=True)
    @marshal
    async def did_update_metadata(
        self,
        request: DIDUpdateMetadata,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> DIDUpdateMetadataResponse:
        wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=DIDWallet)
        async with self.service.wallet_state_manager.lock:
            update_success = await wallet.update_metadata(request.metadata)
            # Update coin with new ID info
            if update_success:
                await wallet.create_update_spend(action_scope, request.fee, extra_conditions=extra_conditions)
                # tx_endpoint wrapper will take care of these default values
                return DIDUpdateMetadataResponse(
                    [],
                    [],
                    wallet_id=request.wallet_id,
                    spend_bundle=WalletSpendBundle([], G2Element()),
                )
            else:
                raise ValueError(f"Couldn't update metadata with input: {request.metadata}")

    @marshal
    async def did_get_did(self, request: DIDGetDID) -> DIDGetDIDResponse:
        wallet = self.service.wallet_state_manager.get_wallet(id=request.wallet_id, required_type=DIDWallet)
        my_did: str = encode_puzzle_hash(bytes32.fromhex(wallet.get_my_DID()), AddressType.DID.hrp(self.service.config))
        async with self.service.wallet_state_manager.lock:
            try:
                coin = await wallet.get_coin()
                return DIDGetDIDResponse(wallet_id=request.wallet_id, my_did=my_did, coin_id=coin.name())
            except RuntimeError:
                return DIDGetDIDResponse(wallet_id=request.wa