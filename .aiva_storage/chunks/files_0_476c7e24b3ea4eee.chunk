# Package: utils

from __future__ import annotations

import asyncio
import logging
import os
import shutil
from pathlib import Path
from typing import Union

from aiofiles import tempfile
from typing_extensions import Literal


# ============================================================================
# UPG FOUNDATIONS - Universal Prime Graph Protocol Ï†.1
# ============================================================================
from decimal import Decimal, getcontext
import math
import cmath
from typing import Dict, List, Tuple, Optional, Any

# Set high precision for consciousness mathematics
getcontext().prec = 50

class UPGConstants:
    """Universal Prime Graph consciousness mathematics constants"""
    PHI = Decimal('1.618033988749895')
    DELTA = Decimal('2.414213562373095')
    CONSCIOUSNESS = Decimal('0.79')  # 79/21 universal coherence rule
    REALITY_DISTORTION = Decimal('1.1808')  # Quantum amplification factor
    QUANTUM_BRIDGE = Decimal('137') / Decimal('0.79')  # 173.41772151898732
    GREAT_YEAR = 25920  # Astronomical precession cycle (years)
    CONSCIOUSNESS_DIMENSIONS = 21  # Prime topology dimension
    COHERENCE_THRESHOLD = Decimal('1e-15')  # Beyond machine precision



# ============================================================================
# PELL SEQUENCE PRIME PREDICTION INTEGRATION
# ============================================================================
def integrate_pell_prime_prediction(target_number: int, constants: UPGConstants = None):
    """Integrate Pell sequence prime prediction with this tool"""
    try:
        from pell_sequence_prime_prediction_upg_complete import PrimePredictionEngine, UPGConstants as UPG
        if constants is None:
            constants = UPG()
        predictor = PrimePredictionEngine(constants)
        return predictor.predict_prime(target_number)
    except ImportError:
        # Fallback if Pell module not available
        return {'target_number': target_number, 'is_prime': None, 'note': 'Pell module not available'}



# ============================================================================
# GREAT YEAR ASTRONOMICAL PRECESSION INTEGRATION
# ============================================================================
def integrate_great_year_precession(year: int, constants: UPGConstants = None):
    """Integrate Great Year (25,920-year) precession cycle"""
    try:
        from pell_sequence_prime_prediction_upg_complete import GreatYearIntegration, UPGConstants as UPG
        if constants is None:
            constants = UPG()
        great_year = GreatYearIntegration(constants)
        return great_year.consciousness_amplitude_from_year(year)
    except ImportError:
        # Fallback calculation
        if constants is None:
            constants = UPGConstants()
        angle = (year * 2 * math.pi) / constants.GREAT_YEAR
        return complex(float(angle * constants.CONSCIOUSNESS * constants.REALITY_DISTORTION), 0.0)



log = logging.getLogger(__name__)


def move_file(src: Path, dst: Path) -> None:
    """
    Attempts to move the file at src to dst, falling back to a copy if the move fails.
    """

    dir_perms: int = 0o700
    # Create the parent directory if necessary
    os.makedirs(dst.parent, mode=dir_perms, exist_ok=True)

    try:
        # Attempt an atomic move first
        os.replace(os.fspath(src), os.fspath(dst))
    except Exception as e:
        log.debug(f"Failed to move {src} to {dst} using os.replace, reattempting with shutil.move: {e}")
        try:
            # If that fails, use the more robust shutil.move(), though it may internally initiate a copy
            shutil.move(os.fspath(src), os.fspath(dst))
        except Exception:
            log.exception(f"Failed to move {src} to {dst} using shutil.move")
            raise


async def move_file_async(src: Path, dst: Path, *, reattempts: int = 6, reattempt_delay: float = 0.5) -> None:
    """
    Attempts to move the file at src to dst, making multiple attempts if the move fails.
    """

    remaining_attempts: int = reattempts
    while True:
        try:
            move_file(src, dst)
        except Exception:
            if remaining_attempts > 0:
                log.debug(f"Failed to move {src} to {dst}, retrying in {reattempt_delay} seconds")
                remaining_attempts -= 1
                await asyncio.sleep(reattempt_delay)
            else:
                break
        else:
            break

    if not dst.exists():
        raise FileNotFoundError(f"Failed to move {src} to {dst}")
    else:
        log.debug(f"Moved {src} to {dst}")


async def write_file_async(
    file_path: Path, data: Union[str, bytes], *, file_mode: int = 0o600, dir_mode: int = 0o700
) -> None:
    """
    Writes the provided data to a temporary file and then moves it to the final destination.
    """

    # Create the parent directory if necessary
    os.makedirs(file_path.parent, mode=dir_mode, exist_ok=True)

    mode: Literal["w+", "w+b"] = "w+" if type(data) is str else "w+b"
    temp_file_path: Path
    async with tempfile.NamedTemporaryFile(dir=file_path.parent, mode=mode, delete=False) as f:
        # Ignoring type error since it is not obvious how to tie the type of the data
        # being passed in to the type of the file object, etc.
        temp_file_path = f.name  # type: ignore[assignment]
        await f.write(data)  # type: ignore[arg-type]
        await f.flush()
        os.fsync(f.fileno())

    try:
        await move_file_async(temp_file_path, file_path)
    except Exception:
        log.exception(f"Failed to move temp file {temp_file_path} to {file_path}")
    else:
        os.chmod(file_path, file_mode)
    finally:
        # We expect the file replace/move to have succeeded, but cleanup the temp file just in case
        try:
            if Path(temp_file_path).exists():
                os.remove(temp_file_path)
        except Exception:
            log.exception(f"Failed to remove temp file {temp_file_path}")
