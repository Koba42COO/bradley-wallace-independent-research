from __future__ import annotations

import dataclasses
import json
import logging
from pathlib import Path
from typing import TYPE_CHECKING, Any, Callable, ClassVar, Optional, cast

from chia_rs import AugSchemeMPL, Coin, CoinSpend, CoinState, G1Element, G2Element, PrivateKey
from chia_rs.sized_bytes import bytes32
from chia_rs.sized_ints import uint8, uint16, uint32, uint64
from clvm_tools.binutils import assemble

from chia.consensus.block_rewards import calculate_base_farmer_reward
from chia.data_layer.data_layer_errors import LauncherCoinNotFoundError
from chia.data_layer.data_layer_util import DLProof, VerifyProofResponse, dl_verify_proof
from chia.data_layer.data_layer_wallet import DataLayerWallet, Mirror
from chia.pools.pool_wallet import PoolWallet
from chia.pools.pool_wallet_info import FARMING_TO_POOL, PoolState, PoolWalletInfo, create_pool_state
from chia.protocols.outbound_message import NodeType
from chia.rpc.rpc_server import Endpoint, EndpointResult, default_get_connections
from chia.rpc.util import ALL_TRANSLATION_LAYERS, RpcEndpoint, marshal
from chia.server.ws_connection import WSChiaConnection
from chia.types.blockchain_format.coin import coin_as_list
from chia.types.blockchain_format.program import INFINITE_COST, Program, run_with_cost
from chia.types.coin_record import CoinRecord
from chia.types.signing_mode import CHIP_0002_SIGN_MESSAGE_PREFIX, SigningMode
from chia.util.bech32m import decode_puzzle_hash, encode_puzzle_hash
from chia.util.byte_types import hexstr_to_bytes
from chia.util.config import load_config
from chia.util.errors import KeychainIsLocked
from chia.util.hash import std_hash
from chia.util.keychain import bytes_to_mnemonic, generate_mnemonic
from chia.util.streamable import Streamable, UInt32Range, streamable
from chia.util.ws_message import WsRpcMessage, create_payload_dict
from chia.wallet.cat_wallet.cat_constants import DEFAULT_CATS
from chia.wallet.cat_wallet.cat_info import CRCATInfo
from chia.wallet.cat_wallet.cat_wallet import CATWallet
from chia.wallet.conditions import (


# ============================================================================
# UPG FOUNDATIONS - Universal Prime Graph Protocol Ï†.1
# ============================================================================
from decimal import Decimal, getcontext
import math
import cmath
from typing import Dict, List, Tuple, Optional, Any

# Set high precision for consciousness mathematics
getcontext().prec = 50

class UPGConstants:
    """Universal Prime Graph consciousness mathematics constants"""
    PHI = Decimal('1.618033988749895')
    DELTA = Decimal('2.414213562373095')
    CONSCIOUSNESS = Decimal('0.79')  # 79/21 universal coherence rule
    REALITY_DISTORTION = Decimal('1.1808')  # Quantum amplification factor
    QUANTUM_BRIDGE = Decimal('137') / Decimal('0.79')  # 173.41772151898732
    GREAT_YEAR = 25920  # Astronomical precession cycle (years)
    CONSCIOUSNESS_DIMENSIONS = 21  # Prime topology dimension
    COHERENCE_THRESHOLD = Decimal('1e-15')  # Beyond machine precision



# ============================================================================
# PELL SEQUENCE PRIME PREDICTION INTEGRATION
# ============================================================================
def integrate_pell_prime_prediction(target_number: int, constants: UPGConstants = None):
    """Integrate Pell sequence prime prediction with this tool"""
    try:
        from pell_sequence_prime_prediction_upg_complete import PrimePredictionEngine, UPGConstants as UPG
        if constants is None:
            constants = UPG()
        predictor = PrimePredictionEngine(constants)
        return predictor.predict_prime(target_number)
    except ImportError:
        # Fallback if Pell module not available
        return {'target_number': target_number, 'is_prime': None, 'note': 'Pell module not available'}



# ============================================================================
# GREAT YEAR ASTRONOMICAL PRECESSION INTEGRATION
# ============================================================================
def integrate_great_year_precession(year: int, constants: UPGConstants = None):
    """Integrate Great Year (25,920-year) precession cycle"""
    try:
        from pell_sequence_prime_prediction_upg_complete import GreatYearIntegration, UPGConstants as UPG
        if constants is None:
            constants = UPG()
        great_year = GreatYearIntegration(constants)
        return great_year.consciousness_amplitude_from_year(year)
    except ImportError:
        # Fallback calculation
        if constants is None:
            constants = UPGConstants()
        angle = (year * 2 * math.pi) / constants.GREAT_YEAR
        return complex(float(angle * constants.CONSCIOUSNESS * constants.REALITY_DISTORTION), 0.0)


    AssertCoinAnnouncement,
    AssertPuzzleAnnouncement,
    Condition,
    ConditionValidTimes,
    CreateCoin,
    CreateCoinAnnouncement,
    CreatePuzzleAnnouncement,
    conditions_from_json_dicts,
    parse_conditions_non_consensus,
    parse_timelock_info,
)
from chia.wallet.derive_keys import (
    MAX_POOL_WALLETS,
    master_sk_to_farmer_sk,
    master_sk_to_pool_sk,
    match_address_to_sk,
)
from chia.wallet.did_wallet import did_wallet_puzzles
from chia.wallet.did_wallet.did_info import DIDCoinData, DIDInfo, did_recovery_is_nil
from chia.wallet.did_wallet.did_wallet import DIDWallet
from chia.wallet.did_wallet.did_wallet_puzzles import (
    DID_INNERPUZ_MOD,
    did_program_to_metadata,
    match_did_puzzle,
    metadata_to_program,
)
from chia.wallet.nft_wallet import nft_puzzle_utils
from chia.wallet.nft_wallet.nft_info import NFTCoinInfo, NFTInfo
from chia.wallet.nft_wallet.nft_puzzle_utils import get_metadata_and_phs
from chia.wallet.nft_wallet.nft_wallet import NFTWallet
from chia.wallet.nft_wallet.uncurry_nft import UncurriedNFT
from chia.wallet.notification_store import Notification
from chia.wallet.outer_puzzles import AssetType
from chia.wallet.puzzle_drivers import PuzzleInfo, Solver
from chia.wallet.puzzles import p2_delegated_conditions
from chia.wallet.puzzles.clawback.metadata import AutoClaimSettings, ClawbackMetadata
from chia.wallet.puzzles.p2_delegated_puzzle_or_hidden_puzzle import puzzle_hash_for_synthetic_public_key
from chia.wallet.signer_protocol import SigningResponse
from chia.wallet.singleton import (
    SINGLETON_LAUNCHER_PUZZLE_HASH,
    create_singleton_puzzle,
    get_inner_puzzle_from_singleton,
)
from chia.wallet.trade_record import TradeRecord
from chia.wallet.trading.offer import Offer, OfferSummary
from chia.wallet.transaction_record import TransactionRecord
from chia.wallet.uncurried_puzzle import uncurry_puzzle
from chia.wallet.util.address_type import AddressType, is_valid_address
from chia.wallet.util.clvm_streamable import json_serialize_with_clvm_streamable
from chia.wallet.util.compute_hints import compute_spend_hints_and_additions
from chia.wallet.util.compute_memos import compute_memos
from chia.wallet.util.curry_and_treehash import NIL_TREEHASH
from chia.wallet.util.query_filter import FilterMode, HashFilter
from chia.wallet.util.transaction_type import CLAWBACK_INCOMING_TRANSACTION_TYPES, TransactionType
from chia.wallet.util.tx_config import DEFAULT_TX_CONFIG, TXConfig, TXConfigLoader
from chia.wallet.util.wallet_sync_utils import fetch_coin_spend_for_coin_state
from chia.wallet.util.wallet_types import CoinType, WalletType
from chia.wallet.vc_wallet.cr_cat_drivers import ProofsChecker
from chia.wallet.vc_wallet.cr_cat_wallet import CRCATWallet
from chia.wallet.vc_wallet.vc_store import VCProofs
from chia.wallet.vc_wallet.vc_wallet import VCWallet
from chia.wallet.wallet import Wallet
from chia.wallet.wallet_action_scope import WalletActionScope
from chia.wallet.wallet_coin_record import WalletCoinRecord
from chia.wallet.wallet_coin_store import CoinRecordOrder, GetCoinRecords, unspent_range
from chia.wallet.wallet_info import WalletInfo
from chia.wallet.wallet_node import WalletNode, get_wallet_db_path
from chia.wallet.wallet_protocol import WalletProtocol
from chia.wallet.wallet_request_types import (
    AddKey,
    AddKeyResponse,
    ApplySignatures,
    ApplySignaturesResponse,
    BalanceResponse,
    CATAssetIDToName,
    CATAssetIDToNameResponse,
    CATGetAssetID,
    CATGetAssetIDResponse,
    CATGetName,
    CATGetNameResponse,
    CATSetName,
    CATSetNameResponse,
    CATSpend,
    CATSpendResponse,
    CheckDeleteKey,
    CheckDeleteKeyResponse,
    CheckOfferValidity,
    CheckOfferValidityResponse,
    CombineCoins,
    CombineCoinsResponse,
    CreateNewDL,
    CreateNewDLResponse,
    CreateOfferForIDs,
    CreateOfferForIDsResponse,
    DefaultCAT,
    DeleteKey,
    DeleteNotifications,
    DeleteUnconfirmedTransactions,
    DIDCreateBackupFile,
    DIDCreateBackupFileResponse,
    DIDFindLostDID,
    DIDFindLostDIDResponse,
    DIDGetCurrentCoinInfo,
    DIDGetCurrentCoinInfoResponse,
    DIDGetDID,
    DIDGetDIDResponse,
    DIDGetInfo,
    DIDGetInfoResponse,
    DIDGetMetadata,
    DIDGetMetadataResponse,
    DIDGetPubkey,
    DIDGetPubkeyResponse,
    DIDGetWalletName,
    DIDGetWalletNameResponse,
    DIDMessageSpend,
    DIDMessageSpendResponse,
    DIDSetWalletName,
    DIDSetWalletNameResponse,
    DIDTransferDID,
    DIDTransferDIDResponse,
    DIDUpdateMetadata,
    DIDUpdateMetadataResponse,
    DLDeleteMirror,
    DLDeleteMirrorResponse,
    DLGetMirrors,
    DLGetMirrorsResponse,
    DLHistory,
    DLHistoryResponse,
    DLLatestSingleton,
    DLLatestSingletonResponse,
    DLNewMirror,
    DLNewMirrorResponse,
    DLOwnedSingletonsResponse,
    DLSingletonsByRoot,
    DLSingletonsByRootResponse,
    DLStopTracking,
    DLTrackNew,
    DLUpdateMultiple,
    DLUpdateMultipleResponse,
    DLUpdateRoot,
    DLUpdateRootResponse,
    Empty,
    ExecuteSigningInstructions,
    ExecuteSigningInstructionsResponse,
    ExtendDerivationIndex,
    ExtendDerivationIndexResponse,
    GatherSigningInfo,
    GatherSigningInfoResponse,
    GenerateMnemonicResponse,
    GetCATListResponse,
    GetCoinRecordsByNames,
    GetCoinRecordsByNamesResponse,
    GetCurrentDerivationIndexResponse,
    GetHeightInfoResponse,
    GetLoggedInFingerprintResponse,
    GetNextAddress,
    GetNextAddressResponse,
    GetNotifications,
    GetNotificationsResponse,
    GetOffersCountResponse,
    GetOfferSummary,
    GetOfferSummaryResponse,
    GetPrivateKey,
    GetPrivateKeyFormat,
    GetPrivateKeyResponse,
    GetPublicKeysResponse,
    GetSpendableCoins,
    GetSpendableCoinsResponse,
    GetStrayCATsResponse,
    GetSyncStatusResponse,
    GetTimestampForHeight,
    GetTimestampForHeightResponse,
    GetTransaction,
    GetTransactionCount,
    GetTransactionCountResponse,
    GetTransactionMemo,
    GetTransactionMemoResponse,
    GetTransactionResponse,
    GetTransactions,
    GetTransactionsResponse,
    GetWalletBalance,
    GetWalletBalanceResponse,
    GetWalletBalances,
    GetWalletBalancesResponse,
    GetWallets,
    GetWalletsResponse,
    LogIn,
    LogInResponse,
    NFTAddURI,
    NFTAddURIResponse,
    NFTCalculateRoyalties,
    NFTCalculateRoyaltiesResponse,
    NFTCountNFTs,
    NFTCountNFTsResponse,
    NFTGetByDID,
    NFTGetByDIDResponse,
    NFTGetInfo,
    NFTGetInfoResponse,
    NFTGetNFTs,
    NFTGetNFTsResponse,
    NFTGetWalletDID,
    NFTGetWalletDIDResponse,
    NFTGetWalletsWithDIDsResponse,
    NFTMintBulk,
    NFTMintBulkResponse,
    NFTMintNFTRequest,
    NFTMintNFTResponse,
    NFTSetDIDBulk,
    NFTSetDIDBulkResponse,
    NFTSetNFTDID,
    NFTSetNFTDIDResponse,
    NFTSetNFTStatus,
    NFTTransferBulk,
    NFTTransferBulkResponse,
    NFTTransferNFT,
    NFTTransferNFTResponse,
    NFTWalletWithDID,
    PushTransactions,
    PushTransactionsResponse,
    PushTX,
    PWAbsorbRewards,
    PWAbsorbRewardsResponse,
    PWJoinPool,
    PWJoinPoolResponse,
    PWSelfPool,
    PWSelfPoolResponse,
    PWStatus,
    PWStatusResponse,
    SelectCoins,
    SelectCoinsResponse,
    SendNotification,
    SendNotificationResponse,
    SendTransaction,
    SendTransactionResponse,
    SetWalletResyncOnStartup,
    SignMessageByAddress,
    SignMessageByAddressResponse,
    SignMessageByID,
    SignMessageByIDResponse,
    SpendClawbackCoins,
    SpendClawbackCoinsResponse,
    SplitCoins,
    SplitCoinsResponse,
    StrayCAT,
    SubmitTransactions,
    SubmitTransactionsResponse,
    TransactionRecordWithMetadata,
    VCAddProofs,
    VCGet,
    VCGetList,
    VCGetListResponse,
    VCGetProofsForRoot,
    VCGetProofsForRootResponse,
    VCGetResponse,
    VCMint,
    VCMintResponse,
    VCProofsRPC,
    VCProofWithHash,
    VCRecordWithCoinID,
    VCRevoke,
    VCRevokeResponse,
    VCSpend,
    VCSpendResponse,
    VerifySignature,
    VerifySignatureResponse,
    WalletInfoResponse,
)
from chia.wallet.wallet_spend_bundle import WalletSpendBundle

# Timeout for response from wallet/full node for sending a transaction
TIMEOUT = 30
MAX_DERIVATION_INDEX_DELTA = 1000
MAX_NFT_CHUNK_SIZE = 25

log = logging.getLogger(__name__)


def tx_endpoint(
    push: bool = False,
    merge_spends: bool = True,
) -> Callable[[RpcEndpoint], RpcEndpoint]:
    def _inner(func: RpcEndpoint) -> RpcEndpoint:
        async def rpc_endpoint(
            self: WalletRpcApi, request: dict[str, Any], *args: object, **kwargs: object
        ) -> EndpointResult:
            if await self.service.wallet_state_manager.synced() is False:
                raise ValueError("Wallet needs to be fully synced before making transactions.")

            assert self.service.logged_in_fingerprint is not None
            tx_config_loader: TXConfigLoader = TXConfigLoader.from_json_dict(request)

            # Some backwards compat fill-ins
            if tx_config_loader.excluded_coin_ids is None:
                tx_config_loader = tx_config_loader.override(
                    excluded_coin_ids=request.get("exclude_coin_ids"),
                )
            if tx_config_loader.excluded_coin_amounts is None:
                tx_config_loader = tx_config_loader.override(
                    excluded_coin_amounts=request.get("exclude_coin_amounts"),
                )
            if tx_config_loader.excluded_coin_ids is None:
                excluded_coins: Optional[list[dict[str, Any]]] = request.get(
                    "exclude_coins", request.get("excluded_coins")
                )
                if excluded_coins is not None:
                    tx_config_loader = tx_config_loader.override(
                        excluded_coin_ids=[Coin.from_json_dict(c).name() for c in excluded_coins],
                    )

            tx_config: TXConfig = tx_config_loader.autofill(
                constants=self.service.wallet_state_manager.constants,
                config=self.service.wallet_state_manager.config,
                logged_in_fingerprint=self.service.logged_in_fingerprint,
            )

            extra_conditions: tuple[Condition, ...] = tuple()
            if "extra_conditions" in request:
                extra_conditions = tuple(conditions_from_json_dicts(request["extra_conditions"]))
            extra_conditions = (*extra_conditions, *ConditionValidTimes.from_json_dict(request).to_conditions())

            valid_times: ConditionValidTimes = parse_timelock_info(extra_conditions)
            if (
                valid_times.max_secs_after_created is not None
                or valid_times.min_secs_since_created is not None
                or valid_times.max_blocks_after_created is not None
                or valid_times.min_blocks_since_created is not None
            ):
                raise ValueError("Relative timelocks are not currently supported in the RPC")

            async with self.service.wallet_state_manager.new_action_scope(
                tx_config,
                push=request.get("push", push),
                merge_spends=request.get("merge_spends", merge_spends),
                sign=request.get("sign", self.service.config.get("auto_sign_txs", True)),
            ) as action_scope:
                response: EndpointResult = await func(
                    self,
                    request,
                    *args,
                    action_scope,
                    extra_conditions=extra_conditions,
                    **kwargs,
                )

            if func.__name__ == "create_new_wallet" and "transactions" not in response:
                # unfortunately, this API isn't solely a tx endpoint
                return response

            unsigned_txs = await self.service.wallet_state_manager.gather_signing_info_for_txs(
                action_scope.side_effects.transactions
            )

            if request.get("CHIP-0029", False):
                response["unsigned_transactions"] = [
                    json_serialize_with_clvm_streamable(
                        tx,
                        translation_layer=(
                            ALL_TRANSLATION_LAYERS[request["translation"]] if "translation" in request else None
                        ),
                    )
                    for tx in unsigned_txs
                ]
            else:
                response["unsigned_transactions"] = [tx.to_json_dict() for tx in unsigned_txs]

            response["transactions"] = [tx.to_json_dict() for tx in action_scope.side_effects.transactions]

            # Some backwards compatibility code here because transaction information being returned was not uniform
            # until the "transactions" key was applied to all of them. Unfortunately, since .add_pending_transactions
            # now applies transformations to the transactions, we have to special case edit all of the previous
            # spots where the information was being surfaced outside of the knowledge of this wrapper.
            new_txs = action_scope.side_effects.transactions
            if "transaction" in response:
                if (
                    func.__name__ == "create_new_wallet" and request["wallet_type"] == "pool_wallet"
                ) or func.__name__ in {"pw_join_pool", "pw_self_pool", "pw_absorb_rewards"}:
                    # Theses RPCs return not "convenience" for some reason
                    response["transaction"] = new_txs[-1].to_json_dict()
                else:
                    response["transaction"] = response["transactions"][0]
            if "tx_record" in response:
                response["tx_record"] = response["transactions"][0]
            if "fee_transaction" in response:
                # Theses RPCs return not "convenience" for some reason
                fee_transactions = [tx for tx in new_txs if tx.wallet_id == 1]
                if len(fee_transactions) == 0:
                    response["fee_transaction"] = None
                else:
                    response["fee_transaction"] = fee_transactions[0].to_json_dict()
            if "transaction_id" in response:
                response["transaction_id"] = new_txs[0].name
            if "transaction_ids" in response:
                response["transaction_ids"] = [
                    tx.name.hex() for tx in new_txs if tx.type == TransactionType.OUTGOING_CLAWBACK.value
                ]
            if "spend_bundle" in response:
                response["spend_bundle"] = WalletSpendBundle.aggregate(
                    [tx.spend_bundle for tx in new_txs if tx.spend_bundle is not None]
                )
            if "signed_txs" in response:
                response["signed_txs"] = response["transactions"]
            if "signed_tx" in response:
                response["signed_tx"] = response["transactions"][0]
            if "tx" in response:
                if func.__name__ == "send_notification":
                    response["tx"] = response["transactions"][0]
                else:
                    response["tx"] = new_txs[0].to_json_dict()
            if "txs" in response:
                response["txs"] = [tx.to_json_dict() for tx in new_txs]
            if "tx_id" in response:
                response["tx_id"] = new_txs[0].name
            if "trade_record" in response:
                old_offer: Offer = Offer.from_bech32(response["offer"])
                signed_coin_spends: list[CoinSpend] = [
                    coin_spend
                    for tx in new_txs
                    if tx.spend_bundle is not None
                    for coin_spend in tx.spend_bundle.coin_spends
                ]
                involved_coins: list[Coin] = [spend.coin for spend in signed_coin_spends]
                signed_coin_spends.extend(
                    [spend for spend in old_offer._bundle.coin_spends if spend.coin not in involved_coins]
                )
                new_offer_bundle = WalletSpendBundle(
                    signed_coin_spends,
                    AugSchemeMPL.aggregate(
                        [tx.spend_bundle.aggregated_signature for tx in new_txs if tx.spend_bundle is not None]
                    ),
                )
                new_offer: Offer = Offer(old_offer.requested_payments, new_offer_bundle, old_offer.driver_dict)
                response["offer"] = new_offer.to_bech32()
                old_trade_record: TradeRecord = TradeRecord.from_json_dict_convenience(
                    response["trade_record"], bytes(old_offer).hex()
                )
                new_trade: TradeRecord = dataclasses.replace(
                    old_trade_record,
                    offer=bytes(new_offer),
                    trade_id=new_offer.name(),
                )
                response["trade_record"] = new_trade.to_json_dict_convenience()
                if (
                    await self.service.wallet_state_manager.trade_manager.trade_store.get_trade_record(
                        old_trade_record.trade_id
                    )
                    is not None
                ):
                    await self.service.wallet_state_manager.trade_manager.trade_store.delete_trade_record(
                        old_trade_record.trade_id
                    )
                    await self.service.wallet_state_manager.trade_manager.save_trade(new_trade, new_offer)
                for tx in await self.service.wallet_state_manager.tx_store.get_transactions_by_trade_id(
                    old_trade_record.trade_id
                ):
                    await self.service.wallet_state_manager.tx_store.add_transaction_record(
                        dataclasses.replace(tx, trade_id=new_trade.trade_id)
                    )

            return response

        return rpc_endpoint

    return _inner


REPLACEABLE_TRANSACTION_RECORD = TransactionRecord(
    confirmed_at_height=uint32(0),
    created_at_time=uint64(0),
    to_puzzle_hash=bytes32.zeros,
    to_address=encode_puzzle_hash(bytes32.zeros, "replace"),
    amount=uint64(0),
    fee_amount=uint64(0),
    confirmed=False,
    sent=uint32(0),
    spend_bundle=WalletSpendBundle([], G2Element()),
    additions=[],
    removals=[],
    wallet_id=uint32(0),
    sent_to=[],
    trade_id=None,
    type=uint32(0),
    name=bytes32.zeros,
    memos={},
    valid_times=ConditionValidTimes(),
)


class WalletRpcApi:
    if TYPE_CHECKING:
        from chia.rpc.rpc_server import RpcApiProtocol

        _protocol_check: ClassVar[RpcApiProtocol] = cast("WalletRpcApi", None)

    max_get_coin_records_limit: ClassVar[uint32] = uint32(1000)
    max_get_coin_records_filter_items: ClassVar[uint32] = uint32(1000)

    def __init__(self, wallet_node: WalletNode):
        assert wallet_node is not None
        self.service = wallet_node
        self.service_name = "chia_wallet"

    def get_routes(self) -> dict[str, Endpoint]:
        return {
            # Key management
            "/log_in": self.log_in,
            "/get_logged_in_fingerprint": self.get_logged_in_fingerprint,
            "/get_public_keys": self.get_public_keys,
            "/get_private_key": self.get_private_key,
            "/generate_mnemonic": self.generate_mnemonic,
            "/add_key": self.add_key,
            "/delete_key": self.delete_key,
            "/check_delete_key": self.check_delete_key,
            "/delete_all_keys": self.delete_all_keys,
            # Wallet node
            "/set_wallet_resync_on_startup": self.set_wallet_resync_on_startup,
            "/get_sync_status": self.get_sync_status,
            "/get_height_info": self.get_height_info,
            "/push_tx": self.push_tx,
            "/push_transactions": self.push_transactions,
            "/get_timestamp_for_height": self.get_timestamp_for_height,
            "/set_auto_claim": self.set_auto_claim,
            "/get_auto_claim": self.get_auto_claim,
            # Wallet management
            "/get_wallets": self.get_wallets,
            "/create_new_wallet": self.create_new_wallet,
            # Wallet
            "/get_wallet_balance": self.get_wallet_balance,
            "/get_wallet_balances": self.get_wallet_balances,
            "/get_transaction": self.get_transaction,
            "/get_transactions": self.get_transactions,
            "/get_transaction_count": self.get_transaction_count,
            "/get_next_address": self.get_next_address,
            "/send_transaction": self.send_transaction,
            "/send_transaction_multi": self.send_transaction_multi,
            "/spend_clawback_coins": self.spend_clawback_coins,
            "/get_coin_records": self.get_coin_records,
            "/get_farmed_amount": self.get_farmed_amount,
            "/create_signed_transaction": self.create_signed_transaction,
            "/delete_unconfirmed_transactions": self.delete_unconfirmed_transactions,
            "/select_coins": self.select_coins,
            "/get_spendable_coins": self.get_spendable_coins,
            "/get_coin_records_by_names": self.get_coin_records_by_names,
            "/get_current_derivation_index": self.get_current_derivation_index,
            "/extend_derivation_index": self.extend_derivation_index,
            "/get_notifications": self.get_notifications,
            "/delete_notifications": self.delete_notifications,
            "/send_notification": self.send_notification,
            "/sign_message_by_address": self.sign_message_by_address,
            "/sign_message_by_id": self.sign_message_by_id,
            "/verify_signature": self.verify_signature,
            "/get_transaction_memo": self.get_transaction_memo,
            "/split_coins": self.split_coins,
            "/combine_coins": self.combine_coins,
            # CATs and trading
            "/cat_set_name": self.cat_set_name,
            "/cat_asset_id_to_name": self.cat_asset_id_to_name,
            "/cat_get_name": self.cat_get_name,
            "/get_stray_cats": self.get_stray_cats,
            "/cat_spend": self.cat_spend,
            "/cat_get_asset_id": self.cat_get_asset_id,
            "/create_offer_for_ids": self.create_offer_for_ids,
            "/get_offer_summary": self.get_offer_summary,
            "/check_offer_validity": self.check_offer_validity,
            "/take_offer": self.take_offer,
            "/get_offer": self.get_offer,
            "/get_all_offers": self.get_all_offers,
            "/get_offers_count": self.get_offers_count,
            "/cancel_offer": self.cancel_offer,
            "/cancel_offers": self.cancel_offers,
            "/get_cat_list": self.get_cat_list,
            # DID Wallet
            "/did_set_wallet_name": self.did_set_wallet_name,
            "/did_get_wallet_name": self.did_get_wallet_name,
            "/did_update_metadata": self.did_update_metadata,
            "/did_get_pubkey": self.did_get_pubkey,
            "/did_get_did": self.did_get_did,
            "/did_get_metadata": self.did_get_metadata,
            "/did_get_current_coin_info": self.did_get_current_coin_info,
            "/did_create_backup_file": self.did_create_backup_file,
            "/did_transfer_did": self.did_transfer_did,
            "/did_message_spend": self.did_message_spend,
            "/did_get_info": self.did_get_info,
            "/did_find_lost_did": self.did_find_lost_did,
            # NFT Wallet
            "/nft_mint_nft": self.nft_mint_nft,
            "/nft_count_nfts": self.nft_count_nfts,
            "/nft_get_nfts": self.nft_get_nfts,
            "/nft_get_by_did": self.nft_get_by_did,
            "/nft_set_nft_did": self.nft_set_nft_did,
            "/nft_set_nft_status": self.nft_set_nft_status,
            "/nft_get_wallet_did": self.nft_get_wallet_did,
            "/nft_get_wallets_with_dids": self.nft_get_wallets_with_dids,
            "/nft_get_info": self.nft_get_info,
            "/nft_transfer_nft": self.nft_transfer_nft,
            "/nft_add_uri": self.nft_add_uri,
            "/nft_calculate_royalties": self.nft_calculate_royalties,
            "/nft_mint_bulk": self.nft_mint_bulk,
            "/nft_set_did_bulk": self.nft_set_did_bulk,
            "/nft_transfer_bulk": self.nft_transfer_bulk,
            # Pool Wallet
            "/pw_join_pool": self.pw_join_pool,
            "/pw_self_pool": self.pw_self_pool,
            "/pw_absorb_rewards": self.pw_absorb_rewards,
            "/pw_status": self.pw_status,
            # DL Wallet
            "/create_new_dl": self.create_new_dl,
            "/dl_track_new": self.dl_track_new,
            "/dl_stop_tracking": self.dl_stop_tracking,
            "/dl_latest_singleton": self.dl_latest_singleton,
            "/dl_singletons_by_root": self.dl_singletons_by_root,
            "/dl_update_root": self.dl_update_root,
            "/dl_update_multiple": self.dl_update_multiple,
            "/dl_history": self.dl_history,
            "/dl_owned_singletons": self.dl_owned_singletons,
            "/dl_get_mirrors": self.dl_get_mirrors,
            "/dl_new_mirror": self.dl_new_mirror,
            "/dl_delete_mirror": self.dl_delete_mirror,
            "/dl_verify_proof": self.dl_verify_proof,
            # Verified Credential
            "/vc_mint": self.vc_mint,
            "/vc_get": self.vc_get,
            "/vc_get_list": self.vc_get_list,
            "/vc_spend": self.vc_spend,
            "/vc_add_proofs": self.vc_add_proofs,
            "/vc_get_proofs_for_root": self.vc_get_proofs_for_root,
            "/vc_revoke": self.vc_revoke,
            # CR-CATs
            "/crcat_approve_pending": self.crcat_approve_pending,
            # Signer Protocol
            "/gather_signing_info": self.gather_signing_info,
            "/apply_signatures": self.apply_signatures,
            "/submit_transactions": self.submit_transactions,
            # Not technically Signer Protocol but related
            "/execute_signing_instructions": self.execute_signing_instructions,
        }

    def get_connections(self, request_node_type: Optional[NodeType]) -> list[dict[str, Any]]:
        return default_get_connections(server=self.service.server, request_node_type=request_node_type)

    async def _state_changed(self, change: str, change_data: Optional[dict[str, Any]]) -> list[WsRpcMessage]:
        """
        Called by the WalletNode or WalletStateManager when something has changed in the wallet. This
        gives us an opportunity to send notifications to all connected clients via WebSocket.
        """
        payloads = []
        if change in {"sync_changed", "coin_added", "add_connection", "close_connection"}:
            # Metrics is the only current consumer for this event
            payloads.append(create_payload_dict(change, change_data, self.service_name, "metrics"))

        payloads.append(create_payload_dict("state_changed", change_data, self.service_name, "wallet_ui"))

        return payloads

    async def _stop_wallet(self) -> None:
        """
        Stops a currently running wallet/key, which allows starting the wallet with a new key.
        Each key has it's own wallet database.
        """
        if self.service is not None:
            self.service._close()
            await self.service._await_closed(shutting_down=False)

    async def _convert_tx_puzzle_hash(self, tx: TransactionRecord) -> TransactionRecord:
        return dataclasses.replace(
            tx,
            to_puzzle_hash=(
                await self.service.wallet_state_manager.convert_puzzle_hash(tx.wallet_id, tx.to_puzzle_hash)
            ),
        )

    async def get_latest_singleton_coin_spend(
        self, peer: WSChiaConnection, coin_id: bytes32, latest: bool = True
    ) -> tuple[CoinSpend, CoinState]:
        coin_state_list: list[CoinState] = await self.service.wallet_state_manager.wallet_node.get_coin_state(
            [coin_id], peer=peer
        )
        if coin_state_list is None or len(coin_state_list) < 1:
            raise ValueError(f"Coin record 0x{coin_id.hex()} not found")
        coin_state: CoinState = coin_state_list[0]
        if latest:
            # Find the unspent coin
            while coin_state.spent_height is not None:
                coin_state_list = await self.service.wallet_state_manager.wallet_node.fetch_children(
                    coin_state.coin.name(), peer=peer
                )
                odd_coin = None
                for coin in coin_state_list:
                    if coin.coin.amount % 2 == 1:
                        if odd_coin is not None:
                            raise ValueError("This is not a singleton, multiple children coins found.")
                        odd_coin = coin
                if odd_coin is None:
                    raise ValueError("Cannot find child coin, please wait then retry.")
                coin_state = odd_coin
        # Get parent coin
        parent_coin_state_list: list[CoinState] = await self.service.wallet_state_manager.wallet_node.get_coin_state(
            [coin_state.coin.parent_coin_info], peer=peer
        )
        if parent_coin_state_list is None or len(parent_coin_state_list) < 1:
            raise ValueError(f"Parent coin record 0x{coin_state.coin.parent_coin_info.hex()} not found")
        parent_coin_state: CoinState = parent_coin_state_list[0]
        coin_spend = await fetch_coin_spend_for_coin_state(parent_coin_state, peer)
        return coin_spend, coin_state

    ##########################################################################################
    # Key management
    ##########################################################################################

    @marshal
    async def log_in(self, request: LogIn) -> LogInResponse:
        """
        Logs in the wallet with a specific key.
        """

        if self.service.logged_in_fingerprint == request.fingerprint:
            return LogInResponse(request.fingerprint)

        await self._stop_wallet()
        started = await self.service._start_with_fingerprint(request.fingerprint)
        if started is True:
            return LogInResponse(request.fingerprint)

        raise ValueError(f"fingerprint {request.fingerprint} not found in keychain or keychain is empty")

    @marshal
    async def get_logged_in_fingerprint(self, request: Empty) -> GetLoggedInFingerprintResponse:
        return GetLoggedInFingerprintResponse(uint32.construct_optional(self.service.logged_in_fingerprint))

    @marshal
    async def get_public_keys(self, request: Empty) -> GetPublicKeysResponse:
        try:
            fingerprints = [key_data.fingerprint for key_data in await self.service.keychain_proxy.get_keys()]
        except KeychainIsLocked:
            return GetPublicKeysResponse(keyring_is_locked=True)
        except Exception as e:
            raise Exception(
                "Error while getting keys.  If the issue persists, restart all services."
                f"  Original error: {type(e).__name__}: {e}"
            ) from e
        else:
            return GetPublicKeysResponse(keyring_is_locked=False, public_key_fingerprints=fingerprints)

    async def _get_private_key(self, fingerprint: int) -> tuple[Optional[PrivateKey], Optional[bytes]]:
        try:
            all_keys = await self.service.keychain_proxy.get_all_private_keys()
            for sk, seed in all_keys:
                if sk.get_g1().get_fingerprint() == fingerprint:
                    return sk, seed
        except Exception as e:
            log.error(f"Failed to get private key by fingerprint: {e}")
        return None, None

    @marshal
    async def get_private_key(self, request: GetPrivateKey) -> GetPrivateKeyResponse:
        sk, seed = await self._get_private_key(request.fingerprint)
        if sk is not None:
            s = bytes_to_mnemonic(seed) if seed is not None else None
            return GetPrivateKeyResponse(
                private_key=GetPrivateKeyFormat(
                    fingerprint=request.fingerprint,
                    sk=sk,
                    pk=sk.get_g1(),
                    farmer_pk=master_sk_to_farmer_sk(sk).get_g1(),
                    pool_pk=master_sk_to_pool_sk(sk).get_g1(),
                    seed=s,
                )
            )

        raise ValueError(f"Could not get a private key for fingerprint {request.fingerprint}")

    @marshal
    async def generate_mnemonic(self, request: Empty) -> GenerateMnemonicResponse:
        return GenerateMnemonicResponse(generate_mnemonic().split(" "))

    @marshal
    async def add_key(self, request: AddKey) -> AddKeyResponse:
        # Adding a key from 24 word mnemonic
        try:
            sk = await self.service.keychain_proxy.add_key(" ".join(request.mnemonic), label=request.label)
        except KeyError as e:
            raise ValueError(f"The word '{e.args[0]}' is incorrect.")

        fingerprint = uint32(sk.get_g1().get_fingerprint())
        await self._stop_wallet()

        # Makes sure the new key is added to config properly
        started = False
        try:
            await self.service.keychain_proxy.check_keys(self.service.root_path)
        except Exception as e:
            log.error(f"Failed to check_keys after adding a new key: {e}")
        started = await self.service._start_with_fingerprint(fingerprint=fingerprint)
        if started is True:
            return AddKeyResponse(fingerprint=fingerprint)
        raise ValueError("Failed to start")

    @marshal
    async def delete_key(self, request: DeleteKey) -> Empty:
        await self._stop_wallet()
        try:
            await self.service.keychain_proxy.delete_key_by_fingerprint(request.fingerprint)
        except Exception as e:
            log.error(f"Failed to delete key by fingerprint: {e}")
            raise e
        path = get_wallet_db_path(
            self.service.root_path,
            self.service.config,
            str(request.fingerprint),
        )
        if path.exists():
            path.unlink()
        return Empty()

    async def _check_key_used_for_rewards(
        self, new_root: Path, sk: PrivateKey, max_ph_to_search: int
    ) -> tuple[bool, bool]:
        """Checks if the given key is used for either the farmer rewards or pool rewards
        returns a tuple of two booleans
        The first is true if the key is used as the Farmer rewards, otherwise false
        The second is true if the key is used as the Pool rewards, otherwise false
        Returns both false if the key cannot be found with the given fingerprint
        """
        if sk is None:
            return False, False

        config: dict[str, Any] = load_config(new_root, "config.yaml")
        farmer_target = config["farmer"].get("xch_target_address", "")
        pool_target = config["pool"].get("xch_target_address", "")
        address_to_check: list[bytes32] = []

        try:
            farmer_decoded = decode_puzzle_hash(farmer_target)
            address_to_check.append(farmer_decoded)
        except ValueError:
            farmer_decoded = None

        try:
            pool_decoded = decode_puzzle_hash(pool_target)
            address_to_check.append(pool_decoded)
        except ValueError:
            pool_decoded = None

        found_addresses: set[bytes32] = match_address_to_sk(sk, address_to_check, max_ph_to_search)
        found_farmer = False
        found_pool = False

        if farmer_decoded is not None:
            found_farmer = farmer_decoded in found_addresses

        if pool_decoded is not None:
            found_pool = pool_decoded in found_addresses

        return found_farmer, found_pool

    @marshal
    async def check_delete_key(self, request: CheckDeleteKey) -> CheckDeleteKeyResponse:
        """Check the key use prior to possible deletion
        checks whether key is used for either farm or pool rewards
        checks if any wallets have a non-zero balance
        """
        used_for_farmer: bool = False
        used_for_pool: bool = False
        wallet_balance: bool = False

        sk, _ = await self._get_private_key(request.fingerprint)
        if sk is not None:
            used_for_farmer, used_for_pool = await self._check_key_used_for_rewards(
                self.service.root_path, sk, request.max_ph_to_search
            )

            if self.service.logged_in_fingerprint != request.fingerprint:
                await self._stop_wallet()
                await self.service._start_with_fingerprint(fingerprint=request.fingerprint)

            wallets: list[WalletInfo] = await self.service.wallet_state_manager.get_all_wallet_info_entries()
            for w in wallets:
                wallet = self.service.wallet_state_manager.wallets[w.id]
                unspent = await self.service.wallet_state_manager.coin_store.get_unspent_coins_for_wallet(w.id)
                balance = await wallet.get_confirmed_balance(unspent)
                pending_balance = await wallet.get_unconfirmed_balance(unspent)

                if (balance + pending_balance) > 0:
                    wallet_balance = True
                    break

        return CheckDeleteKeyResponse(
            fingerprint=request.fingerprint,
            used_for_farmer_rewards=used_for_farmer,
            used_for_pool_rewards=used_for_pool,
            wallet_balance=wallet_balance,
        )

    @marshal
    async def delete_all_keys(self, request: Empty) -> Empty:
        await self._stop_wallet()
        all_key_datas = await self.service.keychain_proxy.get_keys()
        try:
            await self.service.keychain_proxy.delete_all_keys()
        except Exception as e:
            log.error(f"Failed to delete all keys: {e}")
            raise e
        for key_data in all_key_datas:
            path = get_wallet_db_path(
                self.service.root_path,
                self.service.config,
                str(key_data.fingerprint),
            )
            if path.exists():
                path.unlink()
        return Empty()

    ##########################################################################################
    # Wallet Node
    ##########################################################################################
    @marshal
    async def set_wallet_resync_on_startup(self, request: SetWalletResyncOnStartup) -> Empty:
        """
        Resync the current logged in wallet. The transaction and offer records will be kept.
        :param request: optionally pass in `enable` as bool to enable/disable resync
        :return:
        """
        assert self.service.wallet_state_manager is not None
        fingerprint = self.service.logged_in_fingerprint
        if fingerprint is not None:
            self.service.set_resync_on_startup(fingerprint, request.enable)
        else:
            raise ValueError("You need to login into wallet to use this RPC call")
        return Empty()

    @marshal
    async def get_sync_status(self, request: Empty) -> GetSyncStatusResponse:
        sync_mode = self.service.wallet_state_manager.sync_mode
        has_pending_queue_items = self.service.new_peak_queue.has_pending_data_process_items()
        syncing = sync_mode or has_pending_queue_items
        synced = await self.service.wallet_state_manager.synced()
        return GetSyncStatusResponse(synced=synced, syncing=syncing)

    @marshal
    async def get_height_info(self, request: Empty) -> GetHeightInfoResponse:
        height = await self.service.wallet_state_manager.blockchain.get_finished_sync_up_to()
        return GetHeightInfoResponse(height=height)

    @marshal
    async def push_tx(self, request: PushTX) -> Empty:
        nodes = self.service.server.get_connections(NodeType.FULL_NODE)
        if len(nodes) == 0:
            raise ValueError("Wallet is not currently connected to any full node peers")
        await self.service.push_tx(request.spend_bundle)
        return Empty()

    @tx_endpoint(push=True)
    @marshal
    async def push_transactions(
        self,
        request: PushTransactions,
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> PushTransactionsResponse:
        if not action_scope.config.push:
            raise ValueError("Cannot push transactions if push is False")
        async with action_scope.use() as interface:
            interface.side_effects.transactions.extend(request.transactions)
            if request.fee != 0:
                all_conditions_and_origins = [
                    (condition, cs.coin.name())
                    for tx in interface.side_effects.transactions
                    if tx.spend_bundle is not None
                    for cs in tx.spend_bundle.coin_spends
                    for condition in run_with_cost(cs.puzzle_reveal, INFINITE_COST, cs.solution)[1].as_iter()
                ]
                create_coin_announcement = next(
                    condition
                    for condition in parse_conditions_non_consensus(
                        [con for con, coin in all_conditions_and_origins], abstractions=False
                    )
                    if isinstance(condition, CreateCoinAnnouncement)
                )
                announcement_origin = next(
                    coin
                    for condition, coin in all_conditions_and_origins
                    if condition == create_coin_announcement.to_program()
                )
                async with self.service.wallet_state_manager.new_action_scope(
                    dataclasses.replace(
                        action_scope.config.tx_config,
                        excluded_coin_ids=[
                            *action_scope.config.tx_config.excluded_coin_ids,
                            *(c.name() for tx in interface.side_effects.transactions for c in tx.removals),
                        ],
                    ),
                    push=False,
                ) as inner_action_scope:
                    await self.service.wallet_state_manager.main_wallet.create_tandem_xch_tx(
                        request.fee,
                        inner_action_scope,
                        extra_conditions=(
                            *extra_conditions,
                            CreateCoinAnnouncement(
                                create_coin_announcement.msg, announcement_origin
                            ).corresponding_assertion(),
                        ),
                    )

                interface.side_effects.transactions.extend(inner_action_scope.side_effects.transactions)

        return PushTransactionsResponse([], [])  # tx_endpoint takes care of this

    @marshal
    async def get_timestamp_for_height(self, request: GetTimestampForHeight) -> GetTimestampForHeightResponse:
        return GetTimestampForHeightResponse(await self.service.get_timestamp_for_height(request.height))

    @marshal
    async def set_auto_claim(self, request: AutoClaimSettings) -> AutoClaimSettings:
        """
        Set auto claim merkle coins config
        :param request: Example {"enable": true, "tx_fee": 100000, "min_amount": 0, "batch_size": 50}
        :return:
        """
        return AutoClaimSettings.from_json_dict(self.service.set_auto_claim(request))

    @marshal
    async def get_auto_claim(self, request: Empty) -> AutoClaimSettings:
        """
        Get auto claim merkle coins config
        :param request: None
        :return:
        """
        auto_claim_settings = AutoClaimSettings.from_json_dict(
            self.service.wallet_state_manager.config.get("auto_claim", {})
        )
        return auto_claim_settings

    ##########################################################################################
    # Wallet Management
    ##########################################################################################

    @marshal
    async def get_wallets(self, request: GetWallets) -> GetWalletsResponse:
        wallet_type: Optional[WalletType] = None
        if request.type is not None:
            wallet_type = WalletType(request.type)

        wallets: list[WalletInfo] = await self.service.wallet_state_manager.get_all_wallet_info_entries(wallet_type)
        wallet_infos: list[WalletInfoResponse] = []
        for wallet in wallets:
            if request.include_data:
                data = wallet.data
            else:
                data = ""

            if request.include_data and WalletType(wallet.type) is WalletType.CRCAT:
                crcat_info = CRCATInfo.from_bytes(bytes.fromhex(wallet.data))
                authorized_providers = crcat_info.authorized_providers
                proofs_checker_flags = crcat_info.proofs_checker.flags
            else:
                authorized_providers = []
                proofs_checker_flags = []

            wallet_infos.append(
                WalletInfoResponse(
                    wallet.id,
                    wallet.name,
                    wallet.type,
                    data,
                    authorized_providers,
                    proofs_checker_flags,
                )
            )

        return GetWalletsResponse(wallet_infos, uint32.construct_optional(self.service.logged_in_fingerprint))

    @tx_endpoint(push=True)
    async def create_new_wallet(
        self,
        request: dict[str, Any],
        action_scope: WalletActionScope,
        extra_conditions: tuple[Condition, ...] = tuple(),
    ) -> EndpointResult:
        wallet_state_manager = self.service.wallet_state_manager
        main_wallet = wallet_state_manager.main_wallet
        fee = uint64(request.get("fee", 0))

        if request["wallet_type"] == "cat_wallet":
            # If not provided, the name will be autogenerated based on the tail hash.
            name = request.get("name", None)
            if request["mode"] == "new":
                if request.get("test", False):
                    if not action_scope.config.push:
                        raise ValueError("Test CAT minting must be pushed automatically")  # pragma: no cover
                    async with self.service.wallet_state_manager.lock:
                        cat_wallet = await CATWallet.create_new_cat_wallet(
                            wallet_state_manager,
                            main_wallet,
                            {"identifier": "genesis_by_id"},
                            uint64(request["amount"]),
                            action_scope,
                            fee,
                            name,
                        )
                        asset_id = cat_wallet.get_asset_id()
                    self.service.wallet_state_manager.state_changed("wallet_created")
                    return {
                        "type": cat_wallet.type(),
                        "asset_id": asset_id,
                        "wallet_id": cat_wallet.id(),
                        "transactions": None,  # tx_endpoint wrapper will take care of this
                    }
                else:
                    raise ValueError(
                        "Support for this RPC mode has been dropped."
                        " Please use the CAT Admin Tool @ https://github.com/Chia-Network/CAT-admin-tool instead."
                    )

            elif request["mode"] == "existing":
                async with self.service.wallet_state_manager.lock:
                    cat_wallet = await CATWallet.get_or_create_wallet_for_cat(
                        wallet_state_manager, main_wallet, request["asset_id"], name
                    )
                return {"type": cat_wallet.type(), "asset_id": request["asset_id"], "wallet_id": cat_wallet.id()}

            else:  # undefined mode
                pass

        elif request["wallet_type"] == "did_wallet":
            if request["did_type"] == "new":
                if "backup_dids" in request and request["backup_dids"] != []:
                    raise ValueError("Recovery options are no longer supported. `backup_dids` cannot be set.")
                metadata: dict[str, str] = {}
                if "metadata" in request:
                    if type(request["metadata"]) is dict:
                        metadata = request["metadata"]

                async with self.service.wallet_state_manager.lock:
                    did_wallet_name: Optional[str] = request.get("wallet_name", None)
                    if did_wallet_name is not None:
                        did_wallet_name = did_wallet_name.strip()
                    did_wallet: DIDWallet = await DIDWallet.create_new_did_wallet(
                        wallet_state_manager,
                        main_wallet,
                        uint64(request["amount"]),
                        action_scope,
                        metadata,
                        did_wallet_name,
                        uint64(request.get("fee", 0)),
                        extra_conditions=extra_conditions,
                    )

                my_did_id = encode_puzzle_hash(
                    bytes32.fromhex(did_wallet.get_my_DID()), AddressType.DID.hrp(self.service.config)
                )
                nft_wallet_name = did_wallet_name
                if nft_wallet_name is not None:
                    nft_wallet_name = f"{nft_wallet_name} NFT Wallet"
                await NFTWallet.create_new_nft_wallet(
                    wallet_state_manager,
                    main_wallet,
                    bytes32.fromhex(did_wallet.get_my_DID()),
                    nft_wallet_name,
                )
                return {
                    "success": True,
                    "type": did_wallet.type(),
                    "my_did": my_did_id,
                    "wallet_id": did_wallet.id(),
                    "transactions": None,  # tx_endpoint wrapper will take care of this
                }

            elif request["did_type"] == "recovery":
                async with self.service.wallet_state_manager.lock:
                    did_wallet = await DIDWallet.create_new_did_wallet_from_recovery(
                        wallet_state_manager, main_wallet, request["backup_data"]
                    )
                assert did_wallet.did_info.temp_coin is not None
                assert did_wallet.did_info.temp_puzhash is not None
                assert did_wallet.did_info.temp_pubkey is not None
                my_did = did_wallet.get_my_DID()
                coin_name = did_wallet.did_info.temp_coin.name().hex()
                coin_list = coin_as_list(did_wallet.did_info.temp_coin)
                newpuzhash = did_wallet.did_info.temp_puzhash
                pubkey = did_wallet.did_info.temp_pubkey
                return {
                    "success": True,
                    "type": did_wallet.type(),
                    "my_did": my_did,
                    "wallet_id": did_wallet.id(),
                    "coin_name": coin_name,
                    "coin_list": coin_list,
                    "newpuzhash": newpuzhash.hex(),
                    "pubkey": pubkey.hex(),
                    "backup_dids": did_wallet.did_info.backup_ids,
                    "num_verifications_required": did_wallet.did_info.num_of_backup_ids_needed,
                }
            else:  # undefined did_type
                pass
        elif request["wallet_type"] == "nft_wallet":
            for wallet in self.service.wallet_state_manager.wallets.values():
                did_id: Optional[bytes32] = None
                if "did_id" in request and request["did_id"] is not None:
                    did_id = decode_puzzle_hash(request["did_id"])
                if wallet.type() == WalletType.NFT:
                    assert isinstance(wallet, NFTWallet)
                    if wallet.get_did() == did_id:
                        log.info("NFT wallet already existed, skipping.")
                        return {
                            "success": True,
                            "type": wallet.type(),
                            "wallet_id": wallet.id(),
                        }

            async with self.service.wallet_state_manager.lock:
                nft_wallet: NFTWallet = await NFTWallet.create_new_nft_wallet(
                    wallet_state_manager, main_wallet, did_id, request.get("name", None)
                )
            return {
                "success": True,
                "type": nft_wallet.type(),
                "wallet_id": nft_wallet.id(),
            }
        elif request["wallet_type"] == "pool_wallet":
            if request["mode"] == "new":
                if "initial_target_state" not in request:
                    raise AttributeError("Daemon didn't send `initial_target_state`. Try updating the daemon.")

                owner_puzzle_hash: bytes32 = await action_scope.get_puzzle_hash(self.service.wallet_state_manager)

                from chia.pools.pool_wallet_info import initial_pool_state_from_dict

                async with self.service.wallet_state_manager.lock:
                    # We assign a pseudo unique id to each pool wallet, so that each one gets its own deterministic
                    # owner and auth keys. The public keys will go on the blockchain, and the private keys can be found
                    # using the root SK and trying each index from zero. The indexes are not fully unique though,
                    # because the PoolWallet is not created until the tx gets confirmed on chain. Therefore if we
                    # make multiple pool wallets at the same time, they will have the same ID.
                    max_pwi = 1
                    for _, wallet in self.service.wallet_state_manager.wallets.items():
                        if wallet.type() == WalletType.POOLING_WALLET:
                            max_pwi += 1

                    if max_pwi + 1 >= (MAX_POOL_WALLETS - 1):
                        raise ValueError(f"Too many pool wallets ({max_pwi}), cannot create any more on this key.")

                    owner_pk: G1Element = self.service.wallet_state_manager.main_wallet.hardened_pubkey_for_path(
                        # copied from chia.wallet.derive_keys. Could maybe be an exported constant in the future.
                        [12381, 8444, 5, max_pwi]
                    )

                    initial_target_state = initial_pool_state_from_dict(
                        request["initial_target_state"], owner_pk, owner_puzzle_hash
                    )
                    assert initial_target_state is not None

                    try:
                        delayed_address = None
                        if "p2_singleton_delayed_ph" in request:
                            delayed_address = bytes32.from_hexstr(request["p2_singleton_delayed_ph"])

                        p2_singleton_puzzle_hash, launcher_id = await PoolWallet.create_new_pool_wallet_transaction(
                            wallet_state_manager,
                            main_wallet,
                            initial_target_state,
                            action_scope,
                            fee,
                            request.get("p2_singleton_delay_time", None),
                            delayed_address,
                            extra_conditions=extra_conditions,
                        )

                    except Exception as e:
                        raise ValueError(str(e))
                    return {
                        "total_fee": fee * 2,
                        "transaction": None,  # tx_endpoint wrapper will take care of this
                        "transactions": None,  # tx_endpoint wrapper will take care of this
                        "launcher_id": launcher_id.hex(),
                        "p2_singleton_puzzle_hash": p2_singleton_puzzle_hash.hex(),
                    }
            elif request["mode"] == "recovery":
                raise ValueError("Need upgraded singleton for on-chain recovery")

        else:  # undefined wallet_type
            pass

        # TODO: rework this function to report detailed errors for each error case
        return {"success": False, "error": "invalid request"}

    ##########################################################################################
    # Wallet
    ##########################################################################################

    async def _get_wallet_balance(self, wallet_id: uint32) -> BalanceResponse:
        wallet = self.service.wallet_state_manager.wallets[wallet_id]
        balance = await self.service.get_balance(wallet_id)
        wallet_balance = balance.to_json_dict()
        wallet_balance["wallet_id"] = wallet_id
        wallet_balance["wallet_type"] = wallet.type()
        if self.service.logged_in_fingerprint is not None:
            wallet_balance["fingerprint"] = self.service.logged_in_fingerprint
        if wallet.type() in {WalletType.CAT, WalletType.CRCAT, WalletType.RCAT}:
            assert isinstance(wallet, CATWallet)
            wallet_balance["asset_id"] = wallet.get_asset_id()
            if wallet.type() == WalletType.CRCAT:
                assert isinstance(wallet, CRCATWallet)
                wallet_balance["pending_approval_balance"] = await wallet.get_pending_approval_balance()

        return BalanceResponse.from_json_dict(wallet_balance)

    @marshal
    async def get_wallet_balance(self, request: GetWalletBalance) -> GetWalletBalanceResponse:
        return GetWalletBalanceResponse(await self._get_wallet_balance(request.wallet_id))

    @marshal
    async def get_wallet_balances(self, request: GetWalletBalances) -> GetWalletBalancesResponse:
        if request.wallet_ids is not None:
            wallet_ids = request.wallet_ids
        else:
            wallet_ids = list(self.service.wallet_state_manager.wallets.keys())
        return GetWalletBalancesResponse(
            {wallet_id: await self._get_wallet_balance(wallet_id) for wallet_id in wallet_ids}
        )

    @marshal
    async def get_transaction(self, request: GetTransaction) -> GetTransactionResponse:
        tr: Optional[TransactionRecord] = await self.service.wallet_state_manager.get_transaction(
            request.transaction_id
        )
        if tr is None:
            raise ValueError(f"Transaction 0x{request.transaction_id.hex()} not found")

        return GetTransactionResponse(
            await self._convert_tx_puzzle_hash(tr),
            tr.name,
        )

    @marshal
    async def get_transaction_memo(self, request: GetTransactionMemo) -> GetTransactionMemoResponse:
        transaction_id: bytes32 = request.transaction_id
        tr: Optional[TransactionRecord] = await self.service.wallet_state_manager.get_transaction(transaction_id)
        if tr is None:
            raise ValueError(f"Transaction 0x{transaction_id.hex()} not found")
        if tr.spend_bundle is None or len(tr.spend_bundle.coin_spends) == 0:
            if tr.type == uint32(TransactionType.INCOMING_TX.value):
                # Fetch incoming tx coin spend
                peer = self.service.get_full_node_peer()
                assert len(tr.additions) == 1
                coin_state_list: list[CoinState] = await self.service.wallet_state_manager.wallet_node.get_coin_state(
                    [tr.additions[0].parent_coin_info], peer=peer
                )
                assert len(coin_state_list) == 1
                coin_spend = await fetch_coin_spend_for_coin_state(coin_state_list[0], peer)
                tr = dataclasses.replace(tr, spend_bundle=WalletSpendBundle([coin_spend], G2Element()))
            else:
                raise ValueError(f"Transaction 0x{transaction_id.hex()} doesn't have any coin spend.")
        assert tr.spend_bundle is not None
        return GetTransactionMemoResponse({transaction_id: compute_memos(tr.spend_bundle)})

    @tx_endpoint(push=False)
    @marshal
    async def split_coins(
        self, request: SplitCoins, action_scope: WalletActionScope, extra_conditions: tuple[Condition, ...] = tuple()
    ) -> SplitCoinsResponse:
        if request.number_of_coins > 500:
            raise ValueError(f"{request.number_of_coins} coins is greater then the maximum limit of 500 coins.")

        optional_coin = await self.service.wallet_state_manager.coin_store.get_coin_record(request.target_coin_id)
        if optional_coin is None:
            raise ValueError(f"Could not find coin with ID {request.target_coin_id}")
        else:
            coin = optional_coin.coin

        total_amount = request.amount_per_coin * request.number_of_coins

        if coin.amount < total_amount:
            raise ValueError(
                f"Coin amount: {coin.amount} is less than the total amount of the split: {total_amount}, exiting."
            )

        if request.wallet_id not in self.service.wall