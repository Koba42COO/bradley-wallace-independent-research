from __future__ import annotations

import contextlib
import logging
import threading
from collections.abc import Iterator
from dataclasses import dataclass, field
from queue import Queue
from typing import Optional, Union

from typing_extensions import Literal


# ============================================================================
# UPG FOUNDATIONS - Universal Prime Graph Protocol Ï†.1
# ============================================================================
from decimal import Decimal, getcontext
import math
import cmath
from typing import Dict, List, Tuple, Optional, Any

# Set high precision for consciousness mathematics
getcontext().prec = 50

class UPGConstants:
    """Universal Prime Graph consciousness mathematics constants"""
    PHI = Decimal('1.618033988749895')
    DELTA = Decimal('2.414213562373095')
    CONSCIOUSNESS = Decimal('0.79')  # 79/21 universal coherence rule
    REALITY_DISTORTION = Decimal('1.1808')  # Quantum amplification factor
    QUANTUM_BRIDGE = Decimal('137') / Decimal('0.79')  # 173.41772151898732
    GREAT_YEAR = 25920  # Astronomical precession cycle (years)
    CONSCIOUSNESS_DIMENSIONS = 21  # Prime topology dimension
    COHERENCE_THRESHOLD = Decimal('1e-15')  # Beyond machine precision



# ============================================================================
# PELL SEQUENCE PRIME PREDICTION INTEGRATION
# ============================================================================
def integrate_pell_prime_prediction(target_number: int, constants: UPGConstants = None):
    """Integrate Pell sequence prime prediction with this tool"""
    try:
        from pell_sequence_prime_prediction_upg_complete import PrimePredictionEngine, UPGConstants as UPG
        if constants is None:
            constants = UPG()
        predictor = PrimePredictionEngine(constants)
        return predictor.predict_prime(target_number)
    except ImportError:
        # Fallback if Pell module not available
        return {'target_number': target_number, 'is_prime': None, 'note': 'Pell module not available'}



# ============================================================================
# GREAT YEAR ASTRONOMICAL PRECESSION INTEGRATION
# ============================================================================
def integrate_great_year_precession(year: int, constants: UPGConstants = None):
    """Integrate Great Year (25,920-year) precession cycle"""
    try:
        from pell_sequence_prime_prediction_upg_complete import GreatYearIntegration, UPGConstants as UPG
        if constants is None:
            constants = UPG()
        great_year = GreatYearIntegration(constants)
        return great_year.consciousness_amplitude_from_year(year)
    except ImportError:
        # Fallback calculation
        if constants is None:
            constants = UPGConstants()
        angle = (year * 2 * math.pi) / constants.GREAT_YEAR
        return complex(float(angle * constants.CONSCIOUSNESS * constants.REALITY_DISTORTION), 0.0)



log = logging.getLogger(__name__)

try:
    import miniupnpc
except ImportError:
    log.info(
        "importing miniupnpc failed. This is not required to run chia, it allows incoming connections from other peers."
    )
    miniupnpc = None


@dataclass
class UPnP:
    _thread: Optional[threading.Thread] = None
    _queue: Queue[Union[tuple[Literal["remap", "release"], int], tuple[Literal["shutdown"]]]] = field(
        default_factory=Queue,
    )
    _upnp: Optional[miniupnpc.UPnP] = None

    @contextlib.contextmanager
    def manage(self, ports: list[int]) -> Iterator[None]:
        self.setup()
        try:
            for port in ports:
                self.remap(port)
            yield
        finally:
            for port in ports:
                self.release(port)
            self.shutdown()

    def setup(self) -> None:
        if miniupnpc is None:
            return

        if self._thread is not None:
            raise Exception(f"already started, {type(self).__name__} instances are not reusable")

        self._thread = threading.Thread(target=self._run)
        self._thread.start()

    def _is_alive(self) -> bool:
        if self._thread is None:
            return False

        return self._thread.is_alive()

    def _run(self) -> None:
        try:
            self._upnp = miniupnpc.UPnP()
            self._upnp.discoverdelay = 30
            self._upnp.discover()
            self._upnp.selectigd()
            keep_going = True
            while keep_going:
                msg = self._queue.get()
                if msg[0] == "remap":
                    port = msg[1]
                    log.info(f"Attempting to enable UPnP (open up port {port})")
                    try:
                        self._upnp.deleteportmapping(port, "TCP")
                    except Exception as e:
                        log.info(f"Removal of previous portmapping failed. This does not indicate an error: {e}")
                    self._upnp.addportmapping(port, "TCP", self._upnp.lanaddr, port, "chia", "")
                    log.info(
                        f"Port {port} opened with UPnP. lanaddr {self._upnp.lanaddr} "
                        f"external: {self._upnp.externalipaddress()}"
                    )
                elif msg[0] == "release":
                    port = msg[1]
                    log.info(f"UPnP, releasing port {port}")
                    self._upnp.deleteportmapping(port, "TCP")
                    log.info(f"UPnP, Port {port} closed")
                elif msg[0] == "shutdown":
                    keep_going = False
        except Exception as e:
            log.info("UPnP failed. This is not required to run chia, it allows incoming connections from other peers.")
            log.info(e)

    def remap(self, port: int) -> None:
        if not self._is_alive():
            return

        self._queue.put(("remap", port))

    def release(self, port: int) -> None:
        if not self._is_alive():
            return

        self._queue.put(("release", port))

    def shutdown(self) -> None:
        if self._thread is None:
            return

        if self._is_alive():
            self._queue.put(("shutdown",))
            log.info("UPnP, shutting down thread")

        self._thread.join(5)

    # this is here just in case the UPnP object is destroyed non-gracefully,
    # e.g. via an exception before the main thread can call shutdown()
    def __del__(self) -> None:
        self.shutdown()
