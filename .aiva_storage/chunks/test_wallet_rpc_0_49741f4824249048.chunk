from __future__ import annotations

import asyncio
import dataclasses
import io
import json
import logging
import random
import re
from collections.abc import AsyncIterator
from operator import attrgetter
from typing import Any, Optional
from unittest.mock import patch

import aiosqlite
import pytest
from chia_rs import CoinSpend, G1Element, G2Element
from chia_rs.sized_bytes import bytes32
from chia_rs.sized_ints import uint16, uint32, uint64, uint128

from chia._tests.environments.wallet import WalletStateTransition, WalletTestFramework
from chia._tests.util.setup_nodes import SimulatorsAndWalletsServices
from chia._tests.util.time_out_assert import time_out_assert, time_out_assert_not_none
from chia._tests.wallet.cat_wallet.test_cat_wallet import mint_cat
from chia._tests.wallet.test_wallet_coin_store import (


# ============================================================================
# UPG FOUNDATIONS - Universal Prime Graph Protocol Ï†.1
# ============================================================================
from decimal import Decimal, getcontext
import math
import cmath
from typing import Dict, List, Tuple, Optional, Any

# Set high precision for consciousness mathematics
getcontext().prec = 50

class UPGConstants:
    """Universal Prime Graph consciousness mathematics constants"""
    PHI = Decimal('1.618033988749895')
    DELTA = Decimal('2.414213562373095')
    CONSCIOUSNESS = Decimal('0.79')  # 79/21 universal coherence rule
    REALITY_DISTORTION = Decimal('1.1808')  # Quantum amplification factor
    QUANTUM_BRIDGE = Decimal('137') / Decimal('0.79')  # 173.41772151898732
    GREAT_YEAR = 25920  # Astronomical precession cycle (years)
    CONSCIOUSNESS_DIMENSIONS = 21  # Prime topology dimension
    COHERENCE_THRESHOLD = Decimal('1e-15')  # Beyond machine precision



# ============================================================================
# PELL SEQUENCE PRIME PREDICTION INTEGRATION
# ============================================================================
def integrate_pell_prime_prediction(target_number: int, constants: UPGConstants = None):
    """Integrate Pell sequence prime prediction with this tool"""
    try:
        from pell_sequence_prime_prediction_upg_complete import PrimePredictionEngine, UPGConstants as UPG
        if constants is None:
            constants = UPG()
        predictor = PrimePredictionEngine(constants)
        return predictor.predict_prime(target_number)
    except ImportError:
        # Fallback if Pell module not available
        return {'target_number': target_number, 'is_prime': None, 'note': 'Pell module not available'}



# ============================================================================
# GREAT YEAR ASTRONOMICAL PRECESSION INTEGRATION
# ============================================================================
def integrate_great_year_precession(year: int, constants: UPGConstants = None):
    """Integrate Great Year (25,920-year) precession cycle"""
    try:
        from pell_sequence_prime_prediction_upg_complete import GreatYearIntegration, UPGConstants as UPG
        if constants is None:
            constants = UPG()
        great_year = GreatYearIntegration(constants)
        return great_year.consciousness_amplitude_from_year(year)
    except ImportError:
        # Fallback calculation
        if constants is None:
            constants = UPGConstants()
        angle = (year * 2 * math.pi) / constants.GREAT_YEAR
        return complex(float(angle * constants.CONSCIOUSNESS * constants.REALITY_DISTORTION), 0.0)


    get_coin_records_amount_filter_tests,
    get_coin_records_amount_range_tests,
    get_coin_records_coin_id_filter_tests,
    get_coin_records_coin_type_tests,
    get_coin_records_confirmed_range_tests,
    get_coin_records_include_total_count_tests,
    get_coin_records_mixed_tests,
    get_coin_records_offset_limit_tests,
    get_coin_records_order_tests,
    get_coin_records_parent_coin_id_filter_tests,
    get_coin_records_puzzle_hash_filter_tests,
    get_coin_records_reverse_tests,
    get_coin_records_spent_range_tests,
    get_coin_records_wallet_id_tests,
    get_coin_records_wallet_type_tests,
    record_1,
    record_2,
    record_3,
    record_4,
    record_5,
    record_6,
    record_7,
    record_8,
    record_9,
)
from chia.cmds.coins import CombineCMD, SplitCMD
from chia.cmds.param_types import CliAmount
from chia.consensus.block_rewards import calculate_base_farmer_reward, calculate_pool_reward
from chia.full_node.full_node_rpc_client import FullNodeRpcClient
from chia.rpc.rpc_client import ResponseFailureError
from chia.server.server import ChiaServer
from chia.simulator.full_node_simulator import FullNodeSimulator
from chia.simulator.simulator_protocol import FarmNewBlockProtocol
from chia.types.blockchain_format.coin import Coin, coin_as_list
from chia.types.blockchain_format.program import Program
from chia.types.coin_record import CoinRecord
from chia.types.coin_spend import make_spend
from chia.types.peer_info import PeerInfo
from chia.types.signing_mode import SigningMode
from chia.util.bech32m import decode_puzzle_hash, encode_puzzle_hash
from chia.util.config import load_config, lock_and_load_config, save_config
from chia.util.db_wrapper import DBWrapper2
from chia.util.hash import std_hash
from chia.util.streamable import ConversionError, InvalidTypeError
from chia.wallet.cat_wallet.cat_constants import DEFAULT_CATS
from chia.wallet.cat_wallet.cat_utils import CAT_MOD, construct_cat_puzzle
from chia.wallet.cat_wallet.cat_wallet import CATWallet
from chia.wallet.cat_wallet.r_cat_wallet import RCATWallet
from chia.wallet.conditions import (
    ConditionValidTimes,
    ConditionValidTimesAbsolute,
    CreateCoinAnnouncement,
    CreatePuzzleAnnouncement,
    Remark,
    conditions_to_json_dicts,
)
from chia.wallet.derive_keys import master_sk_to_wallet_sk, master_sk_to_wallet_sk_unhardened
from chia.wallet.did_wallet.did_wallet import DIDWallet
from chia.wallet.nft_wallet.nft_wallet import NFTWallet
from chia.wallet.puzzle_drivers import PuzzleInfo
from chia.wallet.puzzles.clawback.metadata import AutoClaimSettings
from chia.wallet.puzzles.p2_delegated_puzzle_or_hidden_puzzle import puzzle_hash_for_pk
from chia.wallet.signer_protocol import UnsignedTransaction
from chia.wallet.trade_record import TradeRecord
from chia.wallet.trading.offer import Offer, OfferSummary
from chia.wallet.trading.trade_status import TradeStatus
from chia.wallet.transaction_record import TransactionRecord
from chia.wallet.transaction_sorting import SortKey
from chia.wallet.uncurried_puzzle import uncurry_puzzle
from chia.wallet.util.address_type import AddressType
from chia.wallet.util.blind_signer_tl import BLIND_SIGNER_TRANSLATION
from chia.wallet.util.clvm_streamable import byte_deserialize_clvm_streamable
from chia.wallet.util.compute_memos import compute_memos
from chia.wallet.util.query_filter import AmountFilter, HashFilter, TransactionTypeFilter
from chia.wallet.util.transaction_type import TransactionType
from chia.wallet.util.tx_config import DEFAULT_COIN_SELECTION_CONFIG, DEFAULT_TX_CONFIG
from chia.wallet.util.wallet_types import CoinType, WalletType
from chia.wallet.wallet import Wallet
from chia.wallet.wallet_coin_record import WalletCoinRecord
from chia.wallet.wallet_coin_store import GetCoinRecords
from chia.wallet.wallet_node import WalletNode, get_wallet_db_path
from chia.wallet.wallet_protocol import WalletProtocol
from chia.wallet.wallet_request_types import (
    AddKey,
    CATAssetIDToName,
    CATGetAssetID,
    CATGetName,
    CATSetName,
    CATSpend,
    CheckDeleteKey,
    CheckOfferValidity,
    ClawbackPuzzleDecoratorOverride,
    CombineCoins,
    CreateOfferForIDs,
    DefaultCAT,
    DeleteKey,
    DeleteNotifications,
    DeleteUnconfirmedTransactions,
    DIDCreateBackupFile,
    DIDGetDID,
    DIDGetMetadata,
    DIDGetPubkey,
    DIDGetWalletName,
    DIDMessageSpend,
    DIDSetWalletName,
    DIDTransferDID,
    DIDUpdateMetadata,
    FungibleAsset,
    GetCoinRecordsByNames,
    GetNextAddress,
    GetNotifications,
    GetOfferSummary,
    GetPrivateKey,
    GetSpendableCoins,
    GetSyncStatusResponse,
    GetTimestampForHeight,
    GetTransaction,
    GetTransactionCount,
    GetTransactions,
    GetWalletBalance,
    GetWalletBalances,
    GetWallets,
    LogIn,
    NFTCalculateRoyalties,
    NFTGetInfo,
    NFTGetNFTs,
    NFTMintNFTRequest,
    NFTTransferNFT,
    PushTransactions,
    PushTX,
    RoyaltyAsset,
    SelectCoins,
    SendNotification,
    SendTransaction,
    SetWalletResyncOnStartup,
    SpendClawbackCoins,
    SplitCoins,
    VerifySignature,
    VerifySignatureResponse,
)
from chia.wallet.wallet_rpc_api import WalletRpcApi
from chia.wallet.wallet_rpc_client import WalletRpcClient
from chia.wallet.wallet_service import WalletService
from chia.wallet.wallet_spend_bundle import WalletSpendBundle

log = logging.getLogger(__name__)


@dataclasses.dataclass
class WalletBundle:
    service: WalletService
    node: WalletNode
    rpc_client: WalletRpcClient
    wallet: Wallet


@dataclasses.dataclass
class FullNodeBundle:
    server: ChiaServer
    api: FullNodeSimulator
    rpc_client: FullNodeRpcClient


@dataclasses.dataclass
class WalletRpcTestEnvironment:
    wallet_1: WalletBundle
    wallet_2: WalletBundle
    full_node: FullNodeBundle


async def check_client_synced(wallet_client: WalletRpcClient) -> bool:
    return (await wallet_client.get_sync_status()).synced


async def farm_transaction_block(full_node_api: FullNodeSimulator, wallet_node: WalletNode) -> None:
    await full_node_api.farm_blocks_to_puzzlehash(count=1)
    await full_node_api.wait_for_wallet_synced(wallet_node=wallet_node, timeout=20)


def check_mempool_spend_count(full_node_api: FullNodeSimulator, num_of_spends: int) -> bool:
    return full_node_api.full_node.mempool_manager.mempool.size() == num_of_spends


async def farm_transaction(
    full_node_api: FullNodeSimulator, wallet_node: WalletNode, spend_bundle: WalletSpendBundle
) -> None:
    spend_bundle_name = spend_bundle.name()
    await time_out_assert(20, full_node_api.full_node.mempool_manager.get_spendbundle, spend_bundle, spend_bundle_name)
    await farm_transaction_block(full_node_api, wallet_node)
    assert full_node_api.full_node.mempool_manager.get_spendbundle(spend_bundle_name) is None


async def generate_funds(full_node_api: FullNodeSimulator, wallet_bundle: WalletBundle, num_blocks: int = 1) -> int:
    wallet_id = uint32(1)
    initial_balances = (await wallet_bundle.rpc_client.get_wallet_balance(GetWalletBalance(wallet_id))).wallet_balance
    ph: bytes32 = decode_puzzle_hash(
        (await wallet_bundle.rpc_client.get_next_address(GetNextAddress(wallet_id, True))).address
    )
    generated_funds = 0
    for _ in range(num_blocks):
        await full_node_api.farm_new_transaction_block(FarmNewBlockProtocol(ph))
        peak_height = full_node_api.full_node.blockchain.get_peak_height()
        assert peak_height is not None
        generated_funds += calculate_pool_reward(peak_height) + calculate_base_farmer_reward(peak_height)

    # Farm a dummy block to confirm the created funds
    await farm_transaction_block(full_node_api, wallet_bundle.node)

    expected_confirmed = initial_balances.confirmed_wallet_balance + generated_funds
    expected_unconfirmed = initial_balances.unconfirmed_wallet_balance + generated_funds
    await time_out_assert(20, get_confirmed_balance, expected_confirmed, wallet_bundle.rpc_client, wallet_id)
    await time_out_assert(20, get_unconfirmed_balance, expected_unconfirmed, wallet_bundle.rpc_client, wallet_id)
    await time_out_assert(20, check_client_synced, True, wallet_bundle.rpc_client)

    return generated_funds


@pytest.fixture(scope="function", params=[True, False])
async def wallet_rpc_environment(
    two_wallet_nodes_services: SimulatorsAndWalletsServices, request: pytest.FixtureRequest, self_hostname: str
) -> AsyncIterator[WalletRpcTestEnvironment]:
    full_node, wallets, bt = two_wallet_nodes_services
    full_node_service = full_node[0]
    full_node_api = full_node_service._api
    full_node_server = full_node_api.full_node.server
    wallet_service = wallets[0]
    wallet_service_2 = wallets[1]
    wallet_node = wallet_service._node
    wallet_node_2 = wallet_service_2._node
    wallet = wallet_node.wallet_state_manager.main_wallet
    wallet_2 = wallet_node_2.wallet_state_manager.main_wallet

    config = bt.config
    hostname = config["self_hostname"]

    if request.param:
        wallet_node.config["trusted_peers"] = {full_node_server.node_id.hex(): full_node_server.node_id.hex()}
        wallet_node_2.config["trusted_peers"] = {full_node_server.node_id.hex(): full_node_server.node_id.hex()}
    else:
        wallet_node.config["trusted_peers"] = {}
        wallet_node_2.config["trusted_peers"] = {}

    await wallet_node.server.start_client(PeerInfo(self_hostname, full_node_server.get_port()), None)
    await wallet_node_2.server.start_client(PeerInfo(self_hostname, full_node_server.get_port()), None)

    assert wallet_service.rpc_server is not None
    async with WalletRpcClient.create_as_context(
        hostname, wallet_service.rpc_server.listen_port, wallet_service.root_path, wallet_service.config
    ) as client:
        assert wallet_service_2.rpc_server is not None
        async with WalletRpcClient.create_as_context(
            hostname, wallet_service_2.rpc_server.listen_port, wallet_service_2.root_path, wallet_service_2.config
        ) as client_2:
            assert full_node_service.rpc_server is not None
            async with FullNodeRpcClient.create_as_context(
                hostname,
                full_node_service.rpc_server.listen_port,
                full_node_service.root_path,
                full_node_service.config,
            ) as client_node:
                wallet_bundle_1 = WalletBundle(wallet_service, wallet_node, client, wallet)
                wallet_bundle_2 = WalletBundle(wallet_service_2, wallet_node_2, client_2, wallet_2)
                node_bundle = FullNodeBundle(full_node_server, full_node_api, client_node)

                yield WalletRpcTestEnvironment(wallet_bundle_1, wallet_bundle_2, node_bundle)


async def create_tx_outputs(wallet: Wallet, output_args: list[tuple[int, Optional[list[str]]]]) -> list[dict[str, Any]]:
    outputs = []
    async with wallet.wallet_state_manager.new_action_scope(DEFAULT_TX_CONFIG, push=True) as action_scope:
        for args in output_args:
            output = {
                "amount": uint64(args[0]),
                "puzzle_hash": await action_scope.get_puzzle_hash(
                    wallet.wallet_state_manager, override_reuse_puzhash_with=False
                ),
            }
            if args[1] is not None:
                assert len(args[1]) > 0
                output["memos"] = args[1]
            outputs.append(output)
    return outputs


async def assert_wallet_types(client: WalletRpcClient, expected: dict[WalletType, int]) -> None:
    for wallet_type in WalletType:
        wallets = (await client.get_wallets(GetWallets(uint16(wallet_type.value)))).wallets
        wallet_count = len(wallets)
        if wallet_type in expected:
            assert wallet_count == expected.get(wallet_type, 0)
            for wallet in wallets:
                assert wallet.type == wallet_type.value


def assert_tx_amounts(
    tx: TransactionRecord,
    outputs: list[dict[str, Any]],
    *,
    amount_fee: uint64,
    change_expected: bool,
    is_cat: bool = False,
) -> None:
    assert tx.fee_amount == amount_fee
    assert tx.amount == sum(output["amount"] for output in outputs)
    expected_additions = len(outputs) + 1 if change_expected else len(outputs)
    assert len(tx.additions) == expected_additions
    addition_amounts = [addition.amount for addition in tx.additions]
    removal_amounts = [removal.amount for removal in tx.removals]
    for output in outputs:
        assert output["amount"] in addition_amounts
    if is_cat:
        assert (sum(removal_amounts) - sum(addition_amounts)) == 0
    else:
        assert (sum(removal_amounts) - sum(addition_amounts)) == amount_fee


async def assert_push_tx_error(node_rpc: FullNodeRpcClient, tx: TransactionRecord) -> None:
    spend_bundle = tx.spend_bundle
    assert spend_bundle is not None
    # check error for a ASSERT_ANNOUNCE_CONSUMED_FAILED and if the error is not there throw a value error
    try:
        await node_rpc.push_tx(spend_bundle)
    except ValueError as error:
        error_string = error.args[0]["error"]
        if error_string.find("ASSERT_ANNOUNCE_CONSUMED_FAILED") == -1:
            raise ValueError from error


async def assert_get_balance(rpc_client: WalletRpcClient, wallet_node: WalletNode, wallet: WalletProtocol[Any]) -> None:
    expected_balance = await wallet_node.get_balance(wallet.id())
    expected_balance_dict = expected_balance.to_json_dict()
    expected_balance_dict.setdefault("pending_approval_balance", None)
    expected_balance_dict["wallet_id"] = wallet.id()
    expected_balance_dict["wallet_type"] = wallet.type()
    expected_balance_dict["fingerprint"] = wallet_node.logged_in_fingerprint
    if wallet.type() in {WalletType.CAT, WalletType.CRCAT}:
        assert isinstance(wallet, CATWallet)
        expected_balance_dict["asset_id"] = "0x" + wallet.get_asset_id()
    else:
        expected_balance_dict["asset_id"] = None
    assert (
        await rpc_client.get_wallet_balance(GetWalletBalance(wallet.id()))
    ).wallet_balance.to_json_dict() == expected_balance_dict


async def tx_in_mempool(client: WalletRpcClient, transaction_id: bytes32) -> bool:
    tx = (await client.get_transaction(GetTransaction(transaction_id))).transaction
    return tx.is_in_mempool()


async def get_confirmed_balance(client: WalletRpcClient, wallet_id: int) -> uint128:
    return (
        await client.get_wallet_balance(GetWalletBalance(uint32(wallet_id)))
    ).wallet_balance.confirmed_wallet_balance


async def get_unconfirmed_balance(client: WalletRpcClient, wallet_id: int) -> uint128:
    return (
        await client.get_wallet_balance(GetWalletBalance(uint32(wallet_id)))
    ).wallet_balance.unconfirmed_wallet_balance


@pytest.mark.anyio
async def test_send_transaction(wallet_rpc_environment: WalletRpcTestEnvironment) -> None:
    env: WalletRpcTestEnvironment = wallet_rpc_environment

    wallet_2: Wallet = env.wallet_2.wallet
    wallet_node: WalletNode = env.wallet_1.node
    full_node_api: FullNodeSimulator = env.full_node.api
    client: WalletRpcClient = env.wallet_1.rpc_client

    generated_funds = await generate_funds(full_node_api, env.wallet_1)

    async with wallet_2.wallet_state_manager.new_action_scope(DEFAULT_TX_CONFIG, push=True) as action_scope:
        addr = encode_puzzle_hash(await action_scope.get_puzzle_hash(wallet_2.wallet_state_manager), "txch")
    tx_amount = uint64(15600000)
    with pytest.raises(ValueError):
        await client.send_transaction(
            SendTransaction(wallet_id=uint32(1), amount=uint64(100000000000000001), address=addr, push=True),
            DEFAULT_TX_CONFIG,
        )

    # Tests sending a basic transaction
    extra_conditions = (Remark(Program.to(("test", None))),)
    non_existent_coin = Coin(bytes32.zeros, bytes32.zeros, uint64(0))
    tx_no_push = (
        await client.send_transaction(
            SendTransaction(
                wallet_id=uint32(1), amount=tx_amount, address=addr, memos=["this is a basic tx"], push=False
            ),
            tx_config=DEFAULT_TX_CONFIG.override(
                excluded_coin_amounts=[uint64(250000000000)],
                excluded_coin_ids=[non_existent_coin.name()],
                reuse_puzhash=True,
            ),
            extra_conditions=extra_conditions,
        )
    ).transaction
    response = await client.fetch(
        "send_transaction",
        {
            "wallet_id": 1,
            "amount": tx_amount,
            "address": addr,
            "fee": 0,
            "memos": ["this is a basic tx"],
            "puzzle_decorator": None,
            "extra_conditions": conditions_to_json_dicts(extra_conditions),
            "exclude_coin_amounts": [250000000000],
            "exclude_coins": [non_existent_coin.to_json_dict()],
            "reuse_puzhash": True,
            "CHIP-0029": True,
            "translation": "CHIP-0028",
            "push": True,
        },
    )
    assert response["success"]
    tx = TransactionRecord.from_json_dict(response["transactions"][0])
    [
        byte_deserialize_clvm_streamable(
            bytes.fromhex(utx), UnsignedTransaction, translation_layer=BLIND_SIGNER_TRANSLATION
        )
        for utx in response["unsigned_transactions"]
    ]
    assert tx == dataclasses.replace(tx_no_push, created_at_time=tx.created_at_time)
    transaction_id = tx.name
    spend_bundle = tx.spend_bundle
    assert spend_bundle is not None

    await time_out_assert(20, tx_in_mempool, True, client, transaction_id)
    await time_out_assert(20, get_unconfirmed_balance, generated_funds - tx_amount, client, 1)

    await farm_transaction(full_node_api, wallet_node, spend_bundle)

    # Checks that the memo can be retrieved
    tx_confirmed = (await client.get_transaction(GetTransaction(transaction_id))).transaction
    assert tx_confirmed.confirmed
    assert len(tx_confirmed.memos) == 1
    assert [b"this is a basic tx"] in tx_confirmed.memos.values()
    assert next(iter(tx_confirmed.memos.keys())) in [a.name() for a in spend_bundle.additions()]

    await time_out_assert(20, get_confirmed_balance, generated_funds - tx_amount, client, 1)


@pytest.mark.anyio
async def test_push_transactions(wallet_rpc_environment: WalletRpcTestEnvironment) -> None:
    env: WalletRpcTestEnvironment = wallet_rpc_environment

    wallet: Wallet = env.wallet_1.wallet
    wallet_node: WalletNode = env.wallet_1.node
    full_node_api: FullNodeSimulator = env.full_node.api
    client: WalletRpcClient = env.wallet_1.rpc_client

    await generate_funds(full_node_api, env.wallet_1, num_blocks=2)

    outputs = await create_tx_outputs(wallet, [(1234321, None)])

    tx = (
        await client.create_signed_transactions(
            outputs,
            tx_config=DEFAULT_TX_CONFIG,
            fee=uint64(100),
        )
    ).signed_tx

    resp_client = await client.push_transactions(
        PushTransactions(transactions=[tx], fee=uint64(10)),
        DEFAULT_TX_CONFIG,
    )
    resp = await client.fetch("push_transactions", {"transactions": [tx.to_json_dict()], "fee": 10})
    assert resp["success"]
    resp = await client.fetch("push_transactions", {"transactions": [bytes(tx).hex()], "fee": 10})
    assert resp["success"]

    spend_bundle = WalletSpendBundle.aggregate(
        [tx.spend_bundle for tx in resp_client.transactions if tx.spend_bundle is not None]
    )
    assert spend_bundle is not None
    await farm_transaction(full_node_api, wallet_node, spend_bundle)

    for tx in resp_client.transactions:
        assert (await client.get_transaction(GetTransaction(transaction_id=tx.name))).transaction.confirmed

    # Just testing NOT failure here really (parsing)
    await client.push_tx(PushTX(spend_bundle))
    resp = await client.fetch("push_tx", {"spend_bundle": bytes(spend_bundle).hex()})
    assert resp["success"]


@pytest.mark.anyio
async def test_get_balance(wallet_rpc_environment: WalletRpcTestEnvironment) -> None:
    env = wallet_rpc_environment
    wallet: Wallet = env.wallet_1.wallet
    wallet_node: WalletNode = env.wallet_1.node
    full_node_api: FullNodeSimulator = env.full_node.api
    wallet_rpc_client = env.wallet_1.rpc_client
    await full_node_api.farm_blocks_to_wallet(2, wallet)
    async with wallet.wallet_state_manager.new_action_scope(DEFAULT_TX_CONFIG, push=True) as action_scope:
        cat_wallet = await CATWallet.create_new_cat_wallet(
            wallet_node.wallet_state_manager,
            wallet,
            {"identifier": "genesis_by_id"},
            uint64(100),
            action_scope,
        )
    await full_node_api.wait_transaction_records_entered_mempool(action_scope.side_effects.transactions)
    await full_node_api.wait_for_wallet_synced(wallet_node)
    await assert_get_balance(wallet_rpc_client, wallet_node, wallet)
    await assert_get_balance(wallet_rpc_client, wallet_node, cat_wallet)


@pytest.mark.anyio
async def test_get_farmed_amount(wallet_rpc_environment: WalletRpcTestEnvironment) -> None:
    env = wallet_rpc_environment
    wallet: Wallet = env.wallet_1.wallet
    full_node_api: FullNodeSimulator = env.full_node.api
    wallet_rpc_client = env.wallet_1.rpc_client
    await full_node_api.farm_blocks_to_wallet(2, wallet)

    get_farmed_amount_result = await wallet_rpc_client.get_farmed_amount()
    get_timestamp_for_height_result = await wallet_rpc_client.get_timestamp_for_height(
        GetTimestampForHeight(uint32(3))
    )  # genesis + 2

    expected_result = {
        "blocks_won": 2,
        "farmed_amount": 4_000_000_000_000,
        "farmer_reward_amount": 500_000_000_000,
        "fee_amount": 0,
        "last_height_farmed": 3,
        "last_time_farmed": get_timestamp_for_height_result.timestamp,
        "pool_reward_amount": 3_500_000_000_000,
        "success": True,
    }
    assert get_farmed_amount_result == expected_result


@pytest.mark.anyio
async def test_get_farmed_amount_with_fee(wallet_rpc_environment: WalletRpcTestEnvironment) -> None:
    env = wallet_rpc_environment
    wallet: Wallet = env.wallet_1.wallet
    full_node_api: FullNodeSimulator = env.full_node.api
    wallet_rpc_client = env.wallet_1.rpc_client
    wallet_node: WalletNode = env.wallet_1.node

    await generate_funds(full_node_api, env.wallet_1)

    fee_amount = 100
    async with wallet.wallet_state_manager.new_action_scope(DEFAULT_TX_CONFIG, push=True) as action_scope:
        await wallet.generate_signed_transaction(
            amounts=[uint64(5)],
            puzzle_hashes=[bytes32.zeros],
            action_scope=action_scope,
            fee=uint64(fee_amount),
        )
        our_ph = await action_scope.get_puzzle_hash(wallet.wallet_state_manager)

    await full_node_api.wait_transaction_records_entered_mempool(records=action_scope.side_effects.transactions)
    await full_node_api.farm_blocks_to_puzzlehash(count=2, farm_to=our_ph, guarantee_transaction_blocks=True)
    await full_node_api.wait_for_wallet_synced(wallet_node=wallet_node, timeout=20)

    result = await wallet_rpc_client.get_farmed_amount()
    assert result["fee_amount"] == fee_amount


@pytest.mark.anyio
async def test_get_timestamp_for_height(wallet_rpc_environment: WalletRpcTestEnvironment) -> None:
    env: WalletRpcTestEnvironment = wallet_rpc_environment

    full_node_api: FullNodeSimulator = env.full_node.api
    client: WalletRpcClient = env.wallet_1.rpc_client

    await generate_funds(full_node_api, env.wallet_1)

    # This tests that the client returns successfully, rather than raising or returning something unexpected
    await client.get_timestamp_for_height(GetTimestampForHeight(uint32(1)))


@pytest.mark.parametrize(
    "output_args, fee, select_coin, is_cat",
    [
        ([(348026, None)], 0, False, False),
        ([(1270495230, ["memo_1"]), (902347, ["memo_2"])], 1, True, False),
        ([(84920, ["memo_1_0", "memo_1_1"]), (1, ["memo_2_0"])], 0, False, False),
        (
            [(32058710, ["memo_1_0", "memo_1_1"]), (1, ["memo_2_0"]), (923, ["memo_3_0", "memo_3_1"])],
            32804,
            True,
            False,
        ),
        ([(1337, ["LEET"]), (81000, ["pingwei"])], 817, False, True),
        ([(120000000000, None), (120000000000, None)], 10000000000, True, False),
    ],
)
@pytest.mark.anyio
async def test_create_signed_transaction(
    wallet_rpc_environment: WalletRpcTestEnvironment,
    output_args: list[tuple[int, Optional[list[str]]]],
    fee: int,
    select_coin: bool,
    is_cat: bool,
) -> None:
    env: WalletRpcTestEnvironment = wallet_rpc_environment

    wallet_2: Wallet = env.wallet_2.wallet
    wallet_1_node: WalletNode = env.wallet_1.node
    wallet_1_rpc: WalletRpcClient = env.wallet_1.rpc_client
    full_node_api: FullNodeSimulator = env.full_node.api
    full_node_rpc: FullNodeRpcClient = env.full_node.rpc_client

    generated_funds = await generate_funds(full_node_api, env.wallet_1)

    wallet_id = 1
    if is_cat:
        generated_funds = 10**9

        res = await wallet_1_rpc.create_new_cat_and_wallet(uint64(generated_funds), test=True)
        assert res["success"]
        wallet_id = res["wallet_id"]

        await time_out_assert(5, check_mempool_spend_count, True, full_node_api, 1)
        for _ in range(5):
            if check_mempool_spend_count(full_node_api, 0):
                break
            await farm_transaction_block(full_node_api, wallet_1_node)

    outputs = await create_tx_outputs(wallet_2, output_args)
    amount_outputs = sum(output["amount"] for output in outputs)
    amount_fee = uint64(fee)

    if is_cat:
        amount_total = amount_outputs
    else:
        amount_total = amount_outputs + amount_fee

    selected_coin = None
    if select_coin:
        select_coins_response = await wallet_1_rpc.select_coins(
            SelectCoins.from_coin_selection_config(
                amount=amount_total, wallet_id=uint32(wallet_id), coin_selection_config=DEFAULT_COIN_SELECTION_CONFIG
            )
        )
        assert len(select_coins_response.coins) == 1
        selected_coin = select_coins_response.coins[0]

    txs = (
        await wallet_1_rpc.create_signed_transactions(
            outputs,
            coins=[selected_coin] if selected_coin is not None else [],
            fee=amount_fee,
            wallet_id=wallet_id,
            # shouldn't actually block it
            tx_config=DEFAULT_TX_CONFIG.override(
                excluded_coin_amounts=[uint64(selected_coin.amount)] if selected_coin is not None else [],
            ),
            push=True,
        )
    ).transactions
    change_expected = not selected_coin or selected_coin.amount - amount_total > 0
    assert_tx_amounts(txs[-1], outputs, amount_fee=amount_fee, change_expected=change_expected, is_cat=is_cat)

    # Farm the transaction and make sure the wallet balance reflects it correct
    spend_bundle = txs[0].spend_bundle
    assert spend_bundle is not None
    await farm_transaction(full_node_api, wallet_1_node, spend_bundle)
    await time_out_assert(20, get_confirmed_balance, generated_funds - amount_total, wallet_1_rpc, wallet_id)

    # Assert every coin comes from the same parent
    additions: list[Coin] = spend_bundle.additions()
    assert len({c.parent_coin_info for c in additions}) == 2 if is_cat else 1

    # Assert you can get the spend for each addition
    for addition in additions:
        cr: Optional[CoinRecord] = await full_node_rpc.get_coin_record_by_name(addition.name())
        assert cr is not None
        spend: Optional[CoinSpend] = await full_node_rpc.get_puzzle_and_solution(
            addition.parent_coin_info, cr.confirmed_block_index
        )
        assert spend is not None

    # Assert the memos are all correct
    addition_dict: dict[bytes32, Coin] = {addition.name(): addition for addition in additions}
    memo_dictionary: dict[bytes32, list[bytes]] = compute_memos(spend_bundle)
    for output in outputs:
        if "memos" in output:
            found: bool = False
            for addition_id, addition in addition_dict.items():
                if (
                    is_cat
                    and addition.amount == output["amount"]
                    and memo_dictionary[addition_id][0] == output["puzzle_hash"]
                    and memo_dictionary[addition_id][1:] == [memo.encode() for memo in output["memos"]]
                ) or (
                    addition.amount == output["amount"]
                    and addition.puzzle_hash == output["puzzle_hash"]
                    and memo_dictionary[addition_id] == [memo.encode() for memo in output["memos"]]
                ):
                    found = True
            assert found


@pytest.mark.anyio
async def test_create_signed_transaction_with_coin_announcement(
    wallet_rpc_environment: WalletRpcTestEnvironment,
) -> None:
    env: WalletRpcTestEnvironment = wallet_rpc_environment

    wallet_2: Wallet = env.wallet_2.wallet
    full_node_api: FullNodeSimulator = env.full_node.api
    client: WalletRpcClient = env.wallet_1.rpc_client
    client_node: FullNodeRpcClient = env.full_node.rpc_client

    await generate_funds(full_node_api, env.wallet_1)

    signed_tx_amount = uint64(888000)
    tx_coin_announcements = [
        CreateCoinAnnouncement(
            std_hash(b"\xca" + std_hash(b"message")),
            std_hash(b"coin_id_1"),
        ),
        CreateCoinAnnouncement(
            bytes(Program.to("a string")),
            std_hash(b"coin_id_2"),
        ),
    ]
    outputs = await create_tx_outputs(wallet_2, [(signed_tx_amount, None)])
    tx_res: TransactionRecord = (
        await client.create_signed_transactions(
            outputs, tx_config=DEFAULT_TX_CONFIG, extra_conditions=(*tx_coin_announcements,)
        )
    ).signed_tx
    assert_tx_amounts(tx_res, outputs, amount_fee=uint64(0), change_expected=True)
    await assert_push_tx_error(client_node, tx_res)


@pytest.mark.anyio
async def test_create_signed_transaction_with_puzzle_announcement(
    wallet_rpc_environment: WalletRpcTestEnvironment,
) -> None:
    env: WalletRpcTestEnvironment = wallet_rpc_environment

    wallet_2: Wallet = env.wallet_2.wallet
    full_node_api: FullNodeSimulator = env.full_node.api
    client: WalletRpcClient = env.wallet_1.rpc_client
    client_node: FullNodeRpcClient = env.full_node.rpc_client

    await generate_funds(full_node_api, env.wallet_1)

    signed_tx_amount = uint64(888000)
    tx_puzzle_announcements = [
        CreatePuzzleAnnouncement(
            std_hash(b"\xca" + std_hash(b"message")),
            std_hash(b"puzzle_hash_1"),
        ),
        CreatePuzzleAnnouncement(
            bytes(Program.to("a string")),
            std_hash(b"puzzle_hash_2"),
        ),
    ]
    outputs = await create_tx_outputs(wallet_2, [(signed_tx_amount, None)])
    tx_res = (
        await client.create_signed_transactions(
            outputs, tx_config=DEFAULT_TX_CONFIG, extra_conditions=(*tx_puzzle_announcements,)
        )
    ).signed_tx
    assert_tx_amounts(tx_res, outputs, amount_fee=uint64(0), change_expected=True)
    await assert_push_tx_error(client_node, tx_res)


@pytest.mark.anyio
async def test_create_signed_transaction_with_excluded_coins(wallet_rpc_environment: WalletRpcTestEnvironment) -> None:
    env: WalletRpcTestEnvironment = wallet_rpc_environment
    wallet_1: Wallet = env.wallet_1.wallet
    wallet_1_rpc: WalletRpcClient = env.wallet_1.rpc_client
    full_node_api: FullNodeSimulator = env.full_node.api
    full_node_rpc: FullNodeRpcClient = env.full_node.rpc_client
    await generate_funds(full_node_api, env.wallet_1)

    async def it_does_not_include_the_excluded_coins() -> None:
        select_coins_response = await wallet_1_rpc.select_coins(
            SelectCoins.from_coin_selection_config(
                amount=uint64(250000000000), wallet_id=uint32(1), coin_selection_config=DEFAULT_COIN_SELECTION_CONFIG
            )
        )
        assert len(select_coins_response.coins) == 1
        outputs = await create_tx_outputs(wallet_1, [(uint64(250000000000), None)])

        tx = (
            await wallet_1_rpc.create_signed_transactions(
                outputs,
                DEFAULT_TX_CONFIG.override(
                    excluded_coin_ids=[c.name() for c in select_coins_response.coins],
                ),
            )
        ).signed_tx

        assert len(tx.removals) == 1
        assert tx.removals[0] != select_coins_response.coins[0]
        assert tx.removals[0].amount == uint64(1750000000000)
        await assert_push_tx_error(full_node_rpc, tx)

    async def it_throws_an_error_when_all_spendable_coins_are_excluded() -> None:
        select_coins_response = await wallet_1_rpc.select_coins(
            SelectCoins.from_coin_selection_config(
                amount=uint64(1750000000000), wallet_id=uint32(1), coin_selection_config=DEFAULT_COIN_SELECTION_CONFIG
            )
        )
        assert len(select_coins_response.coins) == 1
        outputs = await create_tx_outputs(wallet_1, [(uint64(1750000000000), None)])

        with pytest.raises(ValueError):
            await wallet_1_rpc.create_signed_transactions(
                outputs,
                DEFAULT_TX_CONFIG.override(
                    excluded_coin_ids=[c.name() for c in select_coins_response.coins],
                ),
            )

    await it_does_not_include_the_excluded_coins()
    await it_throws_an_error_when_all_spendable_coins_are_excluded()


@pytest.mark.anyio
async def test_spend_clawback_coins(wallet_rpc_environment: WalletRpcTestEnvironment) -> None:
    env: WalletRpcTestEnvironment = wallet_rpc_environment

    wallet_1_node: WalletNode = env.wallet_1.node
    wallet_2_node: WalletNode = env.wallet_2.node
    wallet_1_rpc: WalletRpcClient = env.wallet_1.rpc_client
    wallet_2_rpc: WalletRpcClient = env.wallet_2.rpc_client
    wallet_1 = wallet_1_node.wallet_state_manager.main_wallet
    wallet_2 = wallet_2_node.wallet_state_manager.main_wallet
    full_node_api: FullNodeSimulator = env.full_node.api

    generated_funds = await generate_funds(full_node_api, env.wallet_1, 1)
    await generate_funds(full_node_api, env.wallet_2, 1)
    async with wallet_1.wallet_state_manager.new_action_scope(DEFAULT_TX_CONFIG, push=True) as action_scope:
        wallet_1_puzhash = await action_scope.get_puzzle_hash(wallet_1.wallet_state_manager)
    await full_node_api.wait_for_wallet_synced(wallet_node=wallet_1_node, timeout=20)
    async with wallet_2.wallet_state_manager.new_action_scope(DEFAULT_TX_CONFIG, push=True) as action_scope:
        wallet_2_puzhash = await action_scope.get_puzzle_hash(wallet_2.wallet_state_manager)
    tx = (
        await wallet_1_rpc.send_transaction(
            SendTransaction(
                wallet_id=uint32(1),
                amount=uint64(500),
                address=encode_puzzle_hash(wallet_2_puzhash, "txch"),
                puzzle_decorator=[ClawbackPuzzleDecoratorOverride(decorator="CLAWBACK", clawback_timelock=uint64(5))],
                push=True,
            ),
            tx_config=DEFAULT_TX_CONFIG,
        )
    ).transaction
    clawback_coin_id_1 = tx.additions[0].name()
    assert tx.spend_bundle is not None
    await farm_transaction(full_node_api, wallet_1_node, tx.spend_bundle)
    await full_node_api.wait_for_wallet_synced(wallet_node=wallet_2_node, timeout=20)
    tx = (
        await wallet_2_rpc.send_transaction(
            SendTransaction(
                wallet_id=uint32(1),
                amount=uint64(500),
                address=encode_puzzle_hash(wallet_1_puzhash, "txch"),
                puzzle_decorator=[ClawbackPuzzleDecoratorOverride(decorator="CLAWBACK", clawback_timelock=uint64(5))],
                push=True,
            ),
            tx_config=DEFAULT_TX_CONFIG,
        )
    ).transaction
    assert tx.spend_bundle is not None
    clawback_coin_id_2 = tx.additions[0].name()
    await farm_transaction(full_node_api, wallet_2_node, tx.spend_bundle)
    await time_out_assert(20, get_confirmed_balance, generated_funds - 500, wallet_1_rpc, 1)
    await time_out_assert(20, get_confirmed_balance, generated_funds - 500, wallet_2_rpc, 1)
    await asyncio.sleep(10)
    # Test coin ID is not a Clawback coin
    invalid_coin_id = tx.removals[0].name()
    resp = await wallet_2_rpc.spend_clawback_coins(
        SpendClawbackCoins(coin_ids=[invalid_coin_id], fee=uint64(500), push=True), tx_config=DEFAULT_TX_CONFIG
    )
    assert resp.transaction_ids == []
    # Test unsupported wallet
    coin_record = await wallet_1_node.wallet_state_manager.coin_store.get_coin_record(clawback_coin_id_1)
    assert coin_record is not None
    await wallet_1_node.wallet_state_manager.coin_store.add_coin_record(
        dataclasses.replace(coin_record, wallet_type=WalletType.CAT)
    )
    resp = await wallet_1_rpc.spend_clawback_coins(
        SpendClawbackCoins(coin_ids=[clawback_coin_id_1], fee=uint64(100), push=True), tx_config=DEFAULT_TX_CONFIG
    )
    assert len(resp.transaction_ids) == 0
    # Test missing metadata
    await wallet_1_node.wallet_state_manager.coin_store.add_coin_record(dataclasses.replace(coin_record, metadata=None))
    resp = await wallet_1_rpc.spend_clawback_coins(
        SpendClawbackCoins(coin_ids=[clawback_coin_id_1], fee=uint64(100), push=True), tx_config=DEFAULT_TX_CONFIG
    )
    assert len(resp.transaction_ids) == 0
    # Test missing incoming tx
    coin_record = await wallet_1_node.wallet_state_manager.coin_store.get_coin_record(clawback_coin_id_2)
    assert coin_record is not None
    fake_coin = Coin(coin_record.coin.parent_coin_info, wallet_2_puzhash, coin_record.coin.amount)
    await wallet_1_node.wallet_state_manager.coin_store.add_coin_record(
        dataclasses.replace(coin_record, coin=fake_coin)
    )
    resp = await wallet_1_rpc.spend_clawback_coins(
        SpendClawbackCoins(coin_ids=[fake_coin.name()], fee=uint64(100), push=True), tx_config=DEFAULT_TX_CONFIG
    )
    assert resp.transaction_ids == []
    # Test coin puzzle hash doesn't match the puzzle
    farmed_tx = (await wallet_1.wallet_state_manager.tx_store.get_farming_rewards())[0]
    await wallet_1.wallet_state_manager.tx_store.add_transaction_record(
        dataclasses.replace(farmed_tx, name=fake_coin.name())
    )
    await wallet_1_node.wallet_state_manager.coin_store.add_coin_record(
        dataclasses.replace(coin_record, coin=fake_coin)
    )
    resp = await wallet_1_rpc.spend_clawback_coins(
        SpendClawbackCoins(coin_ids=[fake_coin.name()], fee=uint64(100), push=True), tx_config=DEFAULT_TX_CONFIG
    )
    assert resp.transaction_ids == []
    # Test claim spend
    await wallet_2_rpc.set_auto_claim(
        AutoClaimSettings(
            enabled=False,
            tx_fee=uint64(100),
            min_amount=uint64(0),
            batch_size=uint16(1),
        )
    )
    resp = await wallet_2_rpc.spend_clawback_coins(
        SpendClawbackCoins(coin_ids=[clawback_coin_id_1, clawback_coin_id_2], fee=uint64(100), push=True),
        tx_config=DEFAULT_TX_CONFIG,
    )
    assert len(resp.transaction_ids) == 2
    for clawback_tx in resp.transactions:
        if clawback_tx.spend_bundle is not None:
            await time_out_assert_not_none(
                10, full_node_api.full_node.mempool_manager.get_spendbundle, clawback_tx.spend_bundle.name()
            )
    await farm_transaction_block(full_node_api, wallet_2_node)
    await time_out_assert(20, get_confirmed_balance, generated_funds + 300, wallet_2_rpc, 1)
    # Test spent coin
    resp = await wallet_2_rpc.spend_clawback_coins(
        SpendClawbackCoins(coin_ids=[clawback_coin_id_1], fee=uint64(500), push=True), tx_config=DEFAULT_TX_CONFIG
    )
    assert resp.transaction_ids == []


@pytest.mark.anyio
async def test_send_transaction_multi(wallet_rpc_environment: WalletRpcTestEnvironment) -> None:
    env: WalletRpcTestEnvironment = wallet_rpc_environment

    wallet_2: Wallet = env.wallet_2.wallet
    wallet_node: WalletNode = env.wallet_1.node
    full_node_api: FullNodeSimulator = env.full_node.api
    client: WalletRpcClient = env.wallet_1.rpc_client

    generated_funds = await generate_funds(full_node_api, env.wallet_1)

    select_coins_response = await client.select_coins(
        SelectCoins.from_coin_selection_config(
            amount=uint64(1750000000000), wallet_id=uint32(1), coin_selection_config=DEFAULT_COIN_SELECTION_CONFIG
        )
    )  # we want a coin that won't be selected by default
    outputs = await create_tx_outputs(wallet_2, [(uint64(1), ["memo_1"]), (uint64(2), ["memo_2"])])
    amount_outputs = sum(output["amount"] for output in outputs)
    amount_fee = uint64(amount_outputs + 1)

    send_tx_res: TransactionRecord = (
        await client.send_transaction_multi(
            1,
            outputs,
            DEFAULT_TX_CONFIG,
            coins=select_coins_response.coins,
            fee=amount_fee,
        )
    ).transaction
    spend_bundle = send_tx_res.spend_bundle
    assert spend_bundle is not None
    assert send_tx_res is not None

    assert_tx_amounts(send_tx_res, outputs, amount_fee=amount_fee, change_expected=True)
    assert send_tx_res.removals == select_coins_response.coins

    await farm_transaction(full_node_api, wallet_node, spend_bundle)

    await time_out_assert(20, get_confirmed_balance, generated_funds - amount_outputs - amount_fee, client, 1)

    # Checks that the memo can be retrieved
    tx_confirmed = (await client.get_transaction(GetTransaction(send_tx_res.name))).transaction
    assert tx_confirmed.confirmed
    memos = tx_confirmed.memos
    assert len(memos) == len(outputs)
    for output in outputs:
        assert [output["memos"][0].encode()] in memos.values()
    spend_bundle = send_tx_res.spend_bundle
    assert spend_bundle is not None
    for key in memos.keys():
        assert key in [a.name() for a in spend_bundle.additions()]


@pytest.mark.anyio
async def test_get_transactions(wallet_rpc_environment: WalletRpcTestEnvironment) -> None:
    env: WalletRpcTestEnvironment = wallet_rpc_environment

    wallet: Wallet = env.wallet_1.wallet
    wallet_node: WalletNode = env.wallet_1.node
    full_node_api: FullNodeSimulator = env.full_node.api
    client: WalletRpcClient = env.wallet_1.rpc_client

    await generate_funds(full_node_api, env.wallet_1, 5)

    all_transactions = (await client.get_transactions(GetTransactions(uint32(1)))).transactions
    assert len(all_transactions) >= 10
    # Test transaction pagination
    some_transactions = (await client.get_transactions(GetTransactions(uint32(1), uint16(0), uint16(5)))).transactions
    some_transactions_2 = (
        await client.get_transactions(GetTransactions(uint32(1), uint16(5), uint16(10)))
    ).transactions
    assert some_transactions == all_transactions[0:5]
    assert some_transactions_2 == all_transactions[5:10]

    # Testing sorts
    # Test the default sort (CONFIRMED_AT_HEIGHT)
    assert all_transactions == sorted(all_transactions, key=attrgetter("confirmed_at_height"))
    all_transactions = (await client.get_transactions(GetTransactions(uint32(1), reverse=True))).transactions
    assert all_transactions == sorted(all_transactions, key=attrgetter("confirmed_at_height"), reverse=True)

    # Test RELEVANCE
    async with wallet.wallet_state_manager.new_action_scope(DEFAULT_TX_CONFIG, push=True) as action_scope:
        puzhash = await action_scope.get_puzzle_hash(wallet.wallet_state_manager)
    await full_node_api.wait_for_wallet_synced(wallet_node=wallet_node, timeout=20)
    await client.send_transaction(
        SendTransaction(wallet_id=uint32(1), amount=uint64(1), address=encode_puzzle_hash(puzhash, "txch"), push=True),
        DEFAULT_TX_CONFIG,
    )  # Create a pending tx

    with pytest.raises(ValueError, match="There is no known sort foo"):
        await client.get_transactions(GetTransactions(uint32(1), sort_key="foo"))

    all_transactions = (
        await client.get_transactions(GetTransactions(uint32(1), sort_key=SortKey.RELEVANCE.name))
    ).transactions
    sorted_transactions = sorted(all_transactions, key=attrgetter("created_at_time"), reverse=True)
    sorted_transactions = sorted(sorted_transactions, key=attrgetter("confirmed_at_height"), reverse=True)
    sorted_transactions = sorted(sorted_transactions, key=attrgetter("confirmed"))
    assert all_transactions == sorted_transactions

    all_transactions = (
        await client.get_transactions(GetTransactions(uint32(1), sort_key=SortKey.RELEVANCE.name, reverse=True))
    ).transactions
    sorted_transactions = sorted(all_transactions, key=attrgetter("created_at_time"))
    sorted_transactions = sorted(sorted_transactions, key=attrgetter("confirmed_at_height"))
    sorted_transactions = sorted(sorted_transactions, key=attrgetter("confirmed"), reverse=True)
    assert all_transactions == sorted_transactions

    # Test get_transactions to address
    async with wallet.wallet_state_manager.new_action_scope(DEFAULT_TX_CONFIG, push=True) as action_scope:
        ph_by_addr = await action_scope.get_puzzle_hash(wallet.wallet_state_manager)
    await full_node_api.wait_for_wallet_synced(wallet_node=wallet_node, timeout=20)
    await client.send_transaction(
        SendTransaction(
            wallet_id=uint32(1), amount=uint64(1), address=encode_puzzle_hash(ph_by_addr, "txch"), push=True
        ),
        DEFAULT_TX_CONFIG,
    )
    await full_node_api.wait_for_wallet_synced(wallet_node=wallet_node, timeout=20)
    tx_for_address = (
        await client.get_transactions(GetTransactions(uint32(1), to_address=encode_puzzle_hash(ph_by_addr, "txch")))
    ).transactions
    assert len(tx_for_address) == 1
    assert tx_for_address[0].to_puzzle_hash == ph_by_addr

    # Test type filter
    all_transactions = (
        await client.get_transactions(
            GetTransactions(uint32(1), type_filter=TransactionTypeFilter.include([TransactionType.COINBASE_REWARD]))
        )
    ).transactions
    assert len(all_transactions) == 5
    assert all(transaction.type == TransactionType.COINBASE_REWARD.value for transaction in all_transactions)
    # Test confirmed filter
    all_transactions = (await client.get_transactions(GetTransactions(uint32(1), confirmed=True))).transactions
    assert len(all_transactions) == 10
    assert all(transaction.confirmed for transaction in all_transactions)
    all_transactions = (await client.get_transactions(GetTransactions(uint32(1), confirmed=False))).transactions
    assert len(all_transactions) == 2
    assert all(not transaction.confirmed for transaction in all_transactions)

    # Test bypass broken txs
    await wallet.wallet_state_manager.tx_store.add_transaction_record(
        dataclasses.replace(all_transactions[0], type=uint32(TransactionType.INCOMING_CLAWBACK_SEND))
    )
    all_transactions = (
        await client.get_transactions(
            GetTransactions(
                uint32(1),
                type_filter=TransactionTypeFilter.include([TransactionType.INCOMING_CLAWBACK_SEND]),
                confirmed=False,
            )
        )
    ).transactions
    assert len(all_transactions) == 1


@pytest.mark.anyio
async def test_get_transaction_count(wallet_rpc_environment: WalletRpcTestEnvironment) -> None:
    env: WalletRpcTestEnvironment = wallet_rpc_environment

    full_node_api: FullNodeSimulator = env.full_node.api
    client: WalletRpcClient = env.wallet_1.rpc_client

    await generate_funds(full_node_api, env.wallet_1)

    all_transactions = (await client.get_transactions(GetTransactions(uint32(1)))).transactions
    assert len(all_transactions) > 0
    transaction_count_response = await client.get_transaction_count(GetTransactionCount(uint32(1)))
    assert transaction_count_response.count == len(all_transactions)
    transaction_count_response = await client.get_transaction_count(GetTransactionCount(uint32(1), confirmed=False))
    assert transaction_count_response.count == 0
    transaction_count_response = await client.get_transaction_count(
        GetTransactionCount(
            uint32(1), type_filter=TransactionTypeFilter.include([TransactionType.INCOMING_CLAWBACK_SEND])
        )
    )
    assert transaction_count_response.count == 0


@pytest.mark.parametrize(
    "wallet_environments",
    [
        {
            "num_environments": 2,
            "blocks_needed": [1, 1],
        }
    ],
    indirect=True,
)
@pytest.mark.limit_consensus_modes(reason="irrelevant")
@pytest.mark.parametrize("wallet_type", [CATWallet, RCATWallet])
@pytest.mark.anyio
async def test_cat_endpoints(wallet_environments: WalletTestFramework, wallet_type: type[CATWallet]) -> None:
    env_0 = wallet_environments.environments[0]
    env_1 = wallet_environments.environments[1]
    env_0.wallet_aliases = {
        "xch": 1,
        "cat0": 2,
        "cat1": 3,
    }
    env_1.wallet_aliases = {
        "xch": 1,
        "cat0": 2,
    }
    # Test a deprecated path
    with pytest.raises(ValueError, match="dropped"):
        await env_0.rpc_client.fetch(
            "create_new_wallet",
            {
                "wallet_type": "cat_wallet",
                "mode": "new",
            },
        )

    # Creates a CAT wallet with 100 mojos and a CAT with 20 mojos and fee=10
    await mint_cat(
        wallet_environments,
        env_0,
        "xch",
        "cat0",
        uint64(100),
        wallet_type,
        "cat0",
    )
    await mint_cat(
        wallet_environments,
        env_0,
        "xch",
        "cat1",
        uint64(20),
        wallet_type,
        "cat1",
    )

    cat_0_id = uint32(env_0.wallet_aliases["cat0"])
    # The RPC response contains more than just the balance info but all the
    # balance info should match. We're leveraging the `<=` operator to check
    # for subset on `dict` `.items()`.
    assert (
        env_0.wallet_states[uint32(env_0.wallet_aliases["cat0"])].balance.to_json_dict().items()
        <= (await env_0.rpc_client.get_wallet_balance(GetWalletBalance(cat_0_id))).wallet_balance.to_json_dict().items()
    )
    asset_id = (await env_0.rpc_client.get_cat_asset_id(CATGetAssetID(cat_0_id))).asset_id
    assert (
        await env_0.rpc_client.get_cat_name(CATGetName(cat_0_id))
    ).name == wallet_type.default_wallet_name_for_unknown_cat(asset_id.hex())
    await env_0.rpc_client.set_cat_name(CATSetName(cat_0_id, "My cat"))
    assert (await env_0.rpc_client.get_cat_name(CATGetName(cat_0_id))).name == "My cat"
    asset_to_name_response = await env_0.rpc_client.cat_asset_id_to_name(CATAssetIDToName(asset_id))
    assert asset_to_name_response.wallet_id == cat_0_id
    assert asset_to_name_response.name == "My cat"
    asset_to_name_response = await env_0.rpc_client.cat_asset_id_to_name(CATAssetIDToName(bytes32.zeros))
    assert asset_to_name_response.name is None
    verified_asset_id = next(iter(DEFAULT_CATS.items()))[1]["asset_id"]
    asset_to_name_response = await env_0.rpc_client.cat_asset_id_to_name(
        CATAssetIDToName(bytes32.from_hexstr(verified_asset_id))
    )
    assert asset_to_name_response.wallet_id is None
    assert asset_to_name_response.name == next(iter(DEFAULT_CATS.items()))[1]["name"]

    # Creates a second wallet with the same CAT
    res = await env_1.rpc_client.create_wallet_for_existing_cat(asset_id)
    assert res["success"]
    cat_1_id = res["wallet_id"]
    cat_1_asset_id = bytes.fromhex(res["asset_id"])
    assert cat_1_asset_id == asset_id

    await wallet_environments.process_pending_states(
        [
            WalletStateTransition(),
            WalletStateTransition(
                pre_block_balance_updates={
                    "cat0": {
                        "init": True,
                    }
                },
                post_block_balance_updates={},
            ),
        ]
    )

    addr_0 = (await env_0.rpc_client.get_next_address(GetNextAddress(cat_0_id, False))).address
    addr_1 = (await env_1.rpc_client.get_next_address(GetNextAddress(cat_1_id, False))).address

    assert addr_0 != addr_1

    # Test CAT spend without a fee
    with pytest.raises(ValueError):
        await env_0.rpc_client.cat_spend(
            CATSpend(
                wallet_id=cat_0_id,
                amount=uint64(4),
                inner_address=addr_1,
                fee=uint64(0),
                memos=["the cat memo"],
                push=False,
            ),
            tx_config=wallet_environments.tx_config.override(
                excluded_coin_amounts=[uint64(100)],
                excluded_coin_ids=[bytes32.zeros],
            ),
        )

    # Test some validation errors
    with pytest.raises(
        ValueError,
        match=re.escape('Must specify "additions" or "amount"+"inner_address"+"memos", but not both.'),
    ):
        await env_0.rpc_client.cat_spend(
            CATSpend(
                wallet_id=cat_0_id,
                amount=uint64(4),
                inner_address=addr_1,
                memos=["the cat memo"],
                additions=[],
            ),
            tx_config=wallet_environments.tx_config,
        )

    with pytest.raises(ValueError, match=re.escape('Must specify "amount" and "inner_address" together.')):
        await env_0.rpc_client.cat_spend(
            CATSpend(
                wallet_id=cat_0_id,
                amount=uint64(4),
                inner_address=None,
            ),
            tx_config=wallet_environments.tx_config,
        )

    with pytest.raises(
        ValueError,
        match=re.escape('Must specify \\"extra_delta\\", \\"tail_reveal\\" and \\"tail_solution\\" together.'),
    ):
        await env_0.rpc_client.cat_spend(
            CATSpend(
                wallet_id=cat_0_id,
                additions=[],
                extra_delta="1",
            ),
            tx_config=wallet_environments.tx_config,
        )

    tx_res = await env_0.rpc_client.cat_spend(
        CATSpend(
            wallet_id=cat_0_id,
            amount=uint64(4),
            inner_address=addr_1,
            fee=uint64(0),
            memos=["the cat memo"],
            push=True,
        ),
        tx_config=wallet_environments.tx_config,
    )

    spend_bundle = tx_res.transaction.spend_bundle
    assert spend_bundle is not None
    assert uncurry_puzzle(spend_bundle.coin_spends[0].puzzle_reveal).mod == CAT_MOD

    await wallet_environments.process_pending_states(
        [
            WalletStateTransition(
                pre_block_balance_updates={
                    "cat0": {
                        "unconfirmed_wallet_balance": -4,
                        "spendable_balance": -100,
                        "max_send_amount": -100,
                        "pending_change": 96,
                        "pending_coin_removal_count": 1,
                    }
                },
                post_block_balance_updates={
                    "cat0": {
                        "confirmed_wallet_balance": -4,
                        "spendable_balance": 96,
                        "max_send_amount": 96,
                        "pending_change": -96,
                        "pending_coin_removal_count": -1,
                    }
                },
            ),
            WalletStateTransition(
                pre_block_balance_updates={},
                post_block_balance_updates={
                    "cat0": {
                        "confirmed_wallet_balance": 4,
                        "unconfirmed_wallet_balance": 4,
                        "spendable_balance": 4,
                        "max_send_amount": 4,
                        "unspent_coin_count": 1,
                    }
                },
            ),
        ]
    )

    # Test CAT spend with a fee
    tx_res = await env_0.rpc_client.cat_spend(
        CATSpend(
            wallet_id=cat_0_id,
            amount=uint64(1),
            inner_address=addr_1,
            fee=uint64(5_000_000),
            memos=["the cat memo"],
            push=True,
        ),
        wallet_environments.tx_config,
    )

    spend_bundle = tx_res.transaction.spend_bundle
    assert spend_bundle is not None

    cat_spend_changes = [
        WalletStateTransition(
            pre_block_balance_updates={
                "xch": {
                    "unconfirmed_wallet_balance": -5_000_000,
                    "<=#spendable_balance": -5_000_000,
                    "<=#max_send_amount": -5_000_000,
                    ">=#pending_change": 1,  # any amount increase
                    "unspent_coin_count": 0,
                    "pending_coin_removal_count": 1,
                },
                "cat0": {
                    "unconfirmed_wallet_balance": -1,
                    "<=#spendable_balance": -1,
                    "<=#max_send_amount": -1,
                    ">=#pending_change": 1,
                    "pending_coin_removal_count": 1,
                },
            },
            post_block_balance_updates={
                "xch": {
                    "confirmed_wallet_balance": -5_000_000,
                    ">=#spendable_balance": 1,  # any amount increase
                    ">=#max_send_amount": 1,  # any amount increase
                    "<=#pending_change": -1,  # any amount decrease
                    "unspent_coin_count": 0,
                    "pending_coin_removal_count": -1,
                },
                "cat0": {
                    "confirmed_wallet_balance": -1,
                    ">=#spendable_balance": 1,  # any amount increase
                    ">=#max_send_amount": 1,  # any amount increase
                    "<=#pending_change": -1,  # any amount decrease
                    "pending_coin_removal_count": -1,
                },
            },
        ),
        WalletStateTransition(
            pre_block_balance_updates={},
            post_block_balance_updates={
                "cat0": {
                    "confirmed_wallet_balance": 1,
                    "unconfirmed_wallet_balance": 1,
                    "spendable_balance": 1,
                    "max_send_amount": 1,
                    "unspent_coin_count": 1,
                },
            },
        ),
    ]
    await wallet_environments.process_pending_states(cat_spend_changes)

    # Test CAT spend with a fee and pre-specified removals / coins
    select_coins_response = await env_0.rpc_client.select_coins(
        SelectCoins.from_coin_selection_config(
            amount=uint64(2),
            wallet_id=cat_0_id,
            coin_selection_config=wallet_environments.tx_config.coin_selection_config,
        )
    )
    tx_res = await env_0.rpc_client.cat_spend(
        CATSpend(
            wallet_id=cat_0_id,
            amount=uint64(1),
            inner_address=addr_1,
            fee=uint64(5_000_000),
            memos=["the cat memo"],
            coins=select_coins_response.coins,
            push=True,
        ),
        wallet_environments.tx_config,
    )

    spend_bundle = tx_res.transaction.spend_bundle
    assert spend_bundle is not None
    assert select_coins_response.coins[0] in {removal for tx in tx_res.transactions for removal in tx.removals}

    await wallet_environments.process_pending_states(cat_spend_changes)

    # Test unacknowledged CAT
    await env_0.wallet_state_manager.interested_store.add_unacknowledged_token(
        asset_id, "Unknown", uint32(10000), bytes32(b"\00" * 32)
    )
    stray_cats_response = await env_0.rpc_client.get_stray_cats()
    assert len(stray_cats_response.stray_cats) == 1

    # Test CAT coin selection
    select_coins_response = await env_0.rpc_client.select_coins(
        SelectCoins.from_coin_selection_config(
            amount=uint64(1),
            wallet_id=cat_0_id,
            coin_selection_config=wallet_environments.tx_config.coin_selection_config,
        )
    )
    assert len(select_coins_response.coins) > 0

    # Test get_cat_list
    cat_list = (await env_0.rpc_client.get_cat_list()).cat_list
    assert len(DEFAULT_CATS) == len(cat_list)
    default_cats_set = {
        DefaultCAT(asset_id=bytes32.from_hexstr(cat["asset_id"]), name=cat["name"], symbol=cat["symbol"])
        for cat in DEFAULT_CATS.values()
    }
    assert default_cats_set == set(cat_list)


@pytest.mark.parametrize(
    "wallet_environments",
    [
        {
            "num_environments": 2,
            "blocks_needed": [1, 1],
        }
    ],
    indirect=True,
)
@pytest.mark.limit_consensus_modes(reason="irrelevant")
@pytest.mark.parametrize("wallet_type", [CATWallet, RCATWallet])
@pytest.mark.anyio
async def test_offer_endpoints(wallet_environments: WalletTestFramework, wallet_type: type[CATWallet]) -> None:
    env_1 = wallet_environments.environments[0]
    env_2 = wallet_environments.environments[1]

    env_1.wallet_aliases = {
        "xch": 1,
        "cat": 2,
    }
    env_2.wallet_aliases = {
        "xch": 1,
        "cat": 2,
    }

    # Creates a CAT wallet with 20 mojos
    cat_wallet = await mint_cat(
        wallet_environments,
        env_1,
        "xch",
        "cat",
        uint64(20),
        wallet_type,
        "cat",
    )
    cat_wallet_id = cat_wallet.id()
    cat_asset_id = cat_wallet.cat_info.limitations_program_hash

    # Creates a wallet for the same CAT on wallet_2 and send 4 CAT from wallet_1 to it
    await env_2.rpc_client.create_wallet_for_existing_cat(cat_asset_id)
    wallet_2_address = (await env_2.rpc_client.get_next_address(GetNextAddress(cat_wallet_id, False))).address
    adds = [{"puzzle_hash": decode_puzzle_hash(wallet_2_address), "amount": uint64(4), "memos": ["the cat memo"]}]
    tx_res = (
        await env_1.rpc_client.send_transaction_multi(
            cat_wallet_id, additions=adds, tx_config=wallet_environments.tx_config, fee=uint64(0)
        )
    ).transaction
    spend_bundle = tx_res.spend_bundle
    assert spend_bundle is not None

    await wallet_environments.process_pending_sta