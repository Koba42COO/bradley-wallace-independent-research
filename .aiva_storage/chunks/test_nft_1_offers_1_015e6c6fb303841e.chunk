alletStateTransition(
                pre_block_balance_updates={
                    "xch": {
                        "set_remainder": True,
                    },
                    "cat_taker": {
                        "set_remainder": True,
                    },
                    "nft0": {},
                    "did": {
                        "set_remainder": True,
                    },
                },
                post_block_balance_updates={
                    "xch": {
                        "set_remainder": True,
                    },
                    "cat_taker": {
                        "set_remainder": True,
                    },
                    "nft0": {},
                    "did": {
                        "set_remainder": True,
                    },
                },
            ),
        ]
    )

    did_id_maker = bytes32.fromhex(did_wallet_maker.get_my_DID())
    did_id_taker = bytes32.fromhex(did_wallet_taker.get_my_DID())
    target_puzhash_maker = ph_maker
    target_puzhash_taker = ph_taker
    royalty_puzhash_maker = ph_maker
    royalty_puzhash_taker = ph_taker
    royalty_basis_pts_maker, royalty_basis_pts_taker_1, royalty_basis_pts_taker_2 = (
        royalty_pts[0],
        uint16(royalty_pts[1]),
        uint16(royalty_pts[2]),
    )

    nft_wallet_maker = await NFTWallet.create_new_nft_wallet(
        wsm_maker, wallet_maker, name="NFT WALLET DID 1", did_id=did_id_maker
    )
    nft_wallet_taker = await NFTWallet.create_new_nft_wallet(
        wsm_taker, wallet_taker, name="NFT WALLET DID 1", did_id=did_id_taker
    )
    await env_maker.change_balances({"nft1": {"init": True}})
    await env_taker.change_balances({"nft1": {"init": True}})

    metadata = Program.to(
        [
            ("u", ["https://www.chia.net/img/branding/chia-logo.svg"]),
            ("h", "0xD4584AD463139FA8C0D9F68F4B59F185"),
        ]
    )
    if royalty_basis_pts_maker > 65535:
        with pytest.raises(ValueError):
            async with nft_wallet_maker.wallet_state_manager.new_action_scope(
                wallet_environments.tx_config, push=False
            ) as action_scope:
                await nft_wallet_maker.generate_new_nft(
                    metadata,
                    action_scope,
                    target_puzhash_maker,
                    royalty_puzhash_maker,
                    royalty_basis_pts_maker,  # type: ignore
                    did_id_maker,
                )
        return
    else:
        async with nft_wallet_maker.wallet_state_manager.new_action_scope(
            wallet_environments.tx_config, push=True
        ) as action_scope:
            await nft_wallet_maker.generate_new_nft(
                metadata,
                action_scope,
                target_puzhash_maker,
                royalty_puzhash_maker,
                uint16(royalty_basis_pts_maker),
                did_id_maker,
            )

    async with nft_wallet_taker.wallet_state_manager.new_action_scope(
        wallet_environments.tx_config, push=True
    ) as action_scope:
        await nft_wallet_taker.generate_new_nft(
            metadata,
            action_scope,
            target_puzhash_taker,
            royalty_puzhash_taker,
            royalty_basis_pts_taker_1,
            did_id_taker,
        )

    await wallet_environments.process_pending_states(
        [
            WalletStateTransition(
                pre_block_balance_updates={
                    "xch": {
                        "set_remainder": True,
                    },
                    "did": {
                        "set_remainder": True,
                    },
                    "nft1": {
                        "set_remainder": True,
                    },
                },
                post_block_balance_updates={
                    "xch": {
                        "set_remainder": True,
                    },
                    "did": {
                        "set_remainder": True,
                    },
                    "nft1": {
                        "set_remainder": True,
                    },
                },
            ),
            WalletStateTransition(
                pre_block_balance_updates={
                    "xch": {
                        "set_remainder": True,
                    },
                    "did": {
                        "set_remainder": True,
                    },
                    "nft1": {
                        "set_remainder": True,
                    },
                },
                post_block_balance_updates={
                    "xch": {
                        "set_remainder": True,
                    },
                    "did": {
                        "set_remainder": True,
                    },
                    "nft1": {
                        "set_remainder": True,
                    },
                },
            ),
        ]
    )

    await time_out_assert(30, get_nft_count, 1, nft_wallet_maker)
    await time_out_assert(30, get_nft_count, 1, nft_wallet_taker)

    # MAke one more NFT for the taker
    async with nft_wallet_taker.wallet_state_manager.new_action_scope(
        wallet_environments.tx_config, push=True
    ) as action_scope:
        await nft_wallet_taker.generate_new_nft(
            metadata,
            action_scope,
            target_puzhash_taker,
            royalty_puzhash_taker,
            royalty_basis_pts_taker_2,
            did_id_taker,
        )

    await wallet_environments.process_pending_states(
        [
            WalletStateTransition(),
            WalletStateTransition(
                pre_block_balance_updates={
                    "xch": {
                        "set_remainder": True,
                    },
                    "did": {
                        "set_remainder": True,
                    },
                    "nft1": {
                        "set_remainder": True,
                    },
                },
                post_block_balance_updates={
                    "xch": {
                        "set_remainder": True,
                    },
                    "did": {
                        "set_remainder": True,
                    },
                    "nft1": {
                        "set_remainder": True,
                    },
                },
            ),
        ]
    )

    await time_out_assert(30, get_nft_count, 2, nft_wallet_taker)

    trade_manager_maker = wsm_maker.trade_manager
    trade_manager_taker = wsm_taker.trade_manager
    maker_nfts = await nft_wallet_maker.get_current_nfts()
    taker_nfts = await nft_wallet_taker.get_current_nfts()
    nft_to_offer_asset_id_maker: bytes32 = maker_nfts[0].nft_id
    nft_to_offer_asset_id_taker_1: bytes32 = taker_nfts[0].nft_id
    nft_to_offer_asset_id_taker_2: bytes32 = taker_nfts[1].nft_id
    if royalty_basis_pts_maker > 60000:
        XCH_REQUESTED = 20000
        CAT_REQUESTED = 1000
        FEE = uint64(20000)
    else:
        XCH_REQUESTED = 2000000000000
        CAT_REQUESTED = 100000
        FEE = uint64(2000000000000)

    complex_nft_offer: OfferSpecification = {
        nft_to_offer_asset_id_maker: -1,
        cat_wallet_maker.id(): CAT_REQUESTED * -1,
        1: XCH_REQUESTED,
        nft_to_offer_asset_id_taker_1: 1,
        nft_to_offer_asset_id_taker_2: 1,
        bytes32.from_hexstr(cat_wallet_taker.get_asset_id()): CAT_REQUESTED,
    }

    nft_taker_1_info = match_puzzle(uncurry_puzzle(taker_nfts[0].full_puzzle))
    nft_taker_2_info = match_puzzle(uncurry_puzzle(taker_nfts[1].full_puzzle))
    assert nft_taker_1_info is not None
    assert nft_taker_2_info is not None
    driver_dict = {
        nft_to_offer_asset_id_taker_1: nft_taker_1_info,
        nft_to_offer_asset_id_taker_2: nft_taker_2_info,
        bytes32.from_hexstr(cat_wallet_taker.get_asset_id()): PuzzleInfo(
            {
                "type": "CAT",
                "tail": "0x" + cat_wallet_taker.get_asset_id(),
                **(
                    {}
                    if wallet_type is CATWallet
                    else {"also": {"type": "revocation layer", "hidden_puzzle_hash": "0x" + bytes32.zeros.hex()}}
                ),
            }
        ),
    }

    async with trade_manager_maker.wallet_state_manager.new_action_scope(
        wallet_environments.tx_config, push=False
    ) as action_scope:
        success, trade_make, error = await trade_manager_maker.create_offer_for_ids(
            complex_nft_offer, action_scope, driver_dict=driver_dict, fee=FEE
        )
    assert error is None
    assert success
    assert trade_make is not None

    [maker_offer], signing_response = await wsm_maker.sign_offers([Offer.from_bytes(trade_make.offer)])
    if royalty_basis_pts_maker == 10000:
        with pytest.raises(ValueError):
            async with trade_manager_taker.wallet_state_manager.new_action_scope(
                wallet_environments.tx_config, push=True, additional_signing_responses=signing_response
            ) as action_scope:
                trade_take = await trade_manager_taker.respond_to_offer(
                    Offer.from_bytes(trade_make.offer),
                    env_taker.node.get_full_node_peer(),
                    action_scope,
                    fee=FEE,
                )
        # all done for this test
        return
    else:
        async with trade_manager_taker.wallet_state_manager.new_action_scope(
            wallet_environments.tx_config, push=True, additional_signing_responses=signing_response
        ) as action_scope:
            trade_take = await trade_manager_taker.respond_to_offer(
                maker_offer,
                env_taker.node.get_full_node_peer(),
                action_scope,
                fee=FEE,
            )
    assert trade_take is not None

    maker_royalty_summary = NFTWallet.royalty_calculation(
        {
            nft_to_offer_asset_id_maker: (royalty_puzhash_maker, uint16(royalty_basis_pts_maker)),
        },
        {
            None: uint64(XCH_REQUESTED),
            bytes32.from_hexstr(cat_wallet_taker.get_asset_id()): uint64(CAT_REQUESTED),
        },
    )
    taker_royalty_summary = NFTWallet.royalty_calculation(
        {
            nft_to_offer_asset_id_taker_1: (royalty_puzhash_taker, royalty_basis_pts_taker_1),
            nft_to_offer_asset_id_taker_2: (royalty_puzhash_taker, royalty_basis_pts_taker_2),
        },
        {
            bytes32.from_hexstr(cat_wallet_maker.get_asset_id()): uint64(CAT_REQUESTED),
        },
    )
    maker_xch_royalties_expected = maker_royalty_summary[nft_to_offer_asset_id_maker][0]["amount"]
    maker_cat_royalties_expected = maker_royalty_summary[nft_to_offer_asset_id_maker][1]["amount"]
    taker_cat_royalties_expected = (
        taker_royalty_summary[nft_to_offer_asset_id_taker_1][0]["amount"]
        + taker_royalty_summary[nft_to_offer_asset_id_taker_2][0]["amount"]
    )

    # in the zero royalty case, exact change ends up being selected which complicates things a bit
    xch_coins = int(XCH_REQUESTED / 1_750_000_000_000) + 2 - (1 if royalty_basis_pts_maker == 0 else 0)
    fee_coins = int(FEE / 1_750_000_000_000) + 1 if FEE > 1_750_000_000_000 else 1
    await wallet_environments.process_pending_states(
        [
            WalletStateTransition(
                pre_block_balance_updates={
                    "xch": {
                        "<=#spendable_balance": -FEE,
                        "<=#max_send_amount": -FEE,
                        "pending_coin_removal_count": fee_coins,
                    },
                    "cat_maker": {
                        "<=#spendable_balance": -CAT_REQUESTED - taker_cat_royalties_expected,
                        "<=#max_send_amount": -CAT_REQUESTED - taker_cat_royalties_expected,
                        "pending_coin_removal_count": 1,
                    },
                    "nft1": {
                        "pending_coin_removal_count": 1,
                    },
                },
                post_block_balance_updates={
                    "xch": {
                        "unconfirmed_wallet_balance": XCH_REQUESTED + maker_xch_royalties_expected - FEE,
                        "confirmed_wallet_balance": XCH_REQUESTED + maker_xch_royalties_expected - FEE,
                        ">=#spendable_balance": 1,
                        ">=#max_send_amount": 1,
                        "pending_coin_removal_count": -fee_coins,
                        # Parametrizations make unspent_coin_count too complicated
                        "set_remainder": True,
                    },
                    "cat_maker": {
                        "unconfirmed_wallet_balance": -CAT_REQUESTED - taker_cat_royalties_expected,
                        "confirmed_wallet_balance": -CAT_REQUESTED - taker_cat_royalties_expected,
                        ">=#spendable_balance": 1,
                        ">=#max_send_amount": 1,
                        "pending_coin_removal_count": -1,
                    },
                    "cat_taker": {
                        "init": True,
                        "unconfirmed_wallet_balance": CAT_REQUESTED + maker_cat_royalties_expected,
                        "confirmed_wallet_balance": CAT_REQUESTED + maker_cat_royalties_expected,
                        "spendable_balance": CAT_REQUESTED + maker_cat_royalties_expected,
                        "max_send_amount": CAT_REQUESTED + maker_cat_royalties_expected,
                        # Parametrizations make unspent_coin_count too complicated
                        "set_remainder": True,
                    },
                    "nft1": {
                        "pending_coin_removal_count": -1,
                        "unspent_coin_count": -1,
                    },
                    "nft0": {
                        "unspent_coin_count": 2,
                    },
                },
            ),
            WalletStateTransition(
                pre_block_balance_updates={
                    "xch": {
                        "unconfirmed_wallet_balance": -XCH_REQUESTED - maker_xch_royalties_expected - FEE,
                        "<=#spendable_balance": -XCH_REQUESTED - maker_xch_royalties_expected - FEE,
                        "<=#max_send_amount": -XCH_REQUESTED - maker_xch_royalties_expected - FEE,
                        ">=#pending_change": 0,
                        "pending_coin_removal_count": xch_coins + fee_coins,
                    },
                    "cat_taker": {
                        "unconfirmed_wallet_balance": -CAT_REQUESTED - maker_cat_royalties_expected,
                        "<=#spendable_balance": -CAT_REQUESTED - maker_cat_royalties_expected,
                        "<=#max_send_amount": -CAT_REQUESTED - maker_cat_royalties_expected,
                        ">=#pending_change": 1,
                        "pending_coin_removal_count": 1,
                    },
                    # Royalties don't factor into unconfirmed balance calculations
                    "cat_maker": {
                        "init": True,
                        "unconfirmed_wallet_balance": CAT_REQUESTED,
                    },
                    "nft1": {
                        "pending_coin_removal_count": 2,
                    },
                },
                post_block_balance_updates={
                    "xch": {
                        "confirmed_wallet_balance": -XCH_REQUESTED - maker_xch_royalties_expected - FEE,
                        ">=#spendable_balance": 0,
                        ">=#max_send_amount": 0,
                        "<=#pending_change": 0,
                        "pending_coin_removal_count": -fee_coins - xch_coins,
                        # Parametrizations make unspent_coin_count too complicated
                        "set_remainder": True,
                    },
                    "cat_taker": {
                        "confirmed_wallet_balance": -CAT_REQUESTED - maker_cat_royalties_expected,
                        ">=#spendable_balance": 1,
                        ">=#max_send_amount": 1,
                        "<=#pending_change": -1,
                        "pending_coin_removal_count": -1,
                    },
                    "cat_maker": {
                        "confirmed_wallet_balance": CAT_REQUESTED + taker_cat_royalties_expected,
                        "unconfirmed_wallet_balance": taker_cat_royalties_expected,
                        "spendable_balance": CAT_REQUESTED + taker_cat_royalties_expected,
                        "max_send_amount": CAT_REQUESTED + taker_cat_royalties_expected,
                        # Parametrizations make unspent_coin_count too complicated
                        "set_remainder": True,
                    },
                    "nft1": {
                        "unspent_coin_count": -2,
                        "pending_coin_removal_count": -2,
                    },
                    "nft0": {
                        "unspent_coin_count": 1,
                    },
                },
            ),
        ]
    )

    maker_nfts = await basic_nft_wallet_maker.get_current_nfts()
    taker_nfts = await basic_nft_wallet_taker.get_current_nfts()
    assert len(maker_nfts) == 2
    assert len(taker_nfts) == 1

    assert nft_to_offer_asset_id_maker == taker_nfts[0].nft_id
    assert nft_to_offer_asset_id_taker_1 in [nft.nft_id for nft in maker_nfts]
    assert nft_to_offer_asset_id_taker_2 in [nft.nft_id for nft in maker_nfts]

    # Try another permutation
    HALF_XCH_REQUESTED = int(XCH_REQUESTED / 2)
    complex_nft_offer = {
        cat_wallet_maker.id(): CAT_REQUESTED * -1,
        1: HALF_XCH_REQUESTED,
        bytes32.from_hexstr(cat_wallet_taker.get_asset_id()): CAT_REQUESTED,
        nft_to_offer_asset_id_maker: 1,
    }

    maker_nft_info = match_puzzle(uncurry_puzzle(taker_nfts[0].full_puzzle))
    assert maker_nft_info is not None
    driver_dict = {
        nft_to_offer_asset_id_maker: maker_nft_info,
        bytes32.from_hexstr(cat_wallet_taker.get_asset_id()): PuzzleInfo(
            {
                "type": "CAT",
                "tail": "0x" + cat_wallet_taker.get_asset_id(),
            }
        ),
    }

    async with trade_manager_maker.wallet_state_manager.new_action_scope(
        wallet_environments.tx_config, push=False
    ) as action_scope:
        success, trade_make, error = await trade_manager_maker.create_offer_for_ids(
            complex_nft_offer, action_scope, driver_dict=driver_dict, fee=uint64(0)
        )
    assert error is None
    assert success
    assert trade_make is not None

    [maker_offer], signing_response = await wsm_maker.sign_offers([Offer.from_bytes(trade_make.offer)])
    async with trade_manager_taker.wallet_state_manager.new_action_scope(
        wallet_environments.tx_config, push=True, additional_signing_responses=signing_response
    ) as action_scope:
        trade_take = await trade_manager_taker.respond_to_offer(
            Offer.from_bytes(trade_make.offer),
            env_taker.node.get_full_node_peer(),
            action_scope,
            fee=uint64(0),
        )
    assert trade_take is not None

    await wallet_environments.process_pending_states(
        [
            WalletStateTransition(
                pre_block_balance_updates={
                    "xch": {},
                    "cat_maker": {
                        "<=#spendable_balance": -CAT_REQUESTED,
                        "<=#max_send_amount": -CAT_REQUESTED,
                        "pending_coin_removal_count": 1,
                    },
                },
                post_block_balance_updates={
                    "xch": {
                        "confirmed_wallet_balance": HALF_XCH_REQUESTED,
                        "unconfirmed_wallet_balance": HALF_XCH_REQUESTED,
                        "spendable_balance": HALF_XCH_REQUESTED,
                        "max_send_amount": HALF_XCH_REQUESTED,
                        # parametrization makes unspent_coin_count difficult
                        "set_remainder": True,
                    },
                    "cat_maker": {
                        "confirmed_wallet_balance": -CAT_REQUESTED,
                        "unconfirmed_wallet_balance": -CAT_REQUESTED,
                        ">=#spendable_balance": 1,
                        ">=#max_send_amount": 1,
                        "pending_coin_removal_count": -1,
                        # parametrization makes unspent_coin_count difficult
                        "set_remainder": True,
                    },
                    "cat_taker": {
                        "confirmed_wallet_balance": CAT_REQUESTED,
                        "unconfirmed_wallet_balance": CAT_REQUESTED,
                        "spendable_balance": CAT_REQUESTED,
                        "max_send_amount": CAT_REQUESTED,
                        # parametrization makes unspent_coin_count difficult
                        "set_remainder": True,
                    },
                    "nft0": {
                        "unspent_coin_count": 1,
                    },
                },
            ),
            WalletStateTransition(
                pre_block_balance_updates={
                    "xch": {
                        "unconfirmed_wallet_balance": -HALF_XCH_REQUESTED,
                        "<=#spendable_balance": -HALF_XCH_REQUESTED,
                        "<=#max_send_amount": -HALF_XCH_REQUESTED,
                        ">=#pending_change": 1,
                        "pending_coin_removal_count": 1,
                    },
                    "cat_maker": {
                        "unconfirmed_wallet_balance": CAT_REQUESTED,
                    },
                    "cat_taker": {
                        "unconfirmed_wallet_balance": -CAT_REQUESTED,
                        "<=#spendable_balance": -CAT_REQUESTED,
                        "<=#max_send_amount": -CAT_REQUESTED,
                        ">=#pending_change": 1,
                        "pending_coin_removal_count": 1,
                    },
                    "nft0": {
                        "pending_coin_removal_count": 1,
                    },
                },
                post_block_balance_updates={
                    "xch": {
                        "confirmed_wallet_balance": -HALF_XCH_REQUESTED,
                        ">=#spendable_balance": 1,
                        ">=#max_send_amount": 1,
                        "<=#pending_change": -1,
                        "pending_coin_removal_count": -1,
                    },
                    "cat_maker": {
                        "confirmed_wallet_balance": CAT_REQUESTED,
                        "spendable_balance": CAT_REQUESTED,
                        "max_send_amount": CAT_REQUESTED,
                        # parametrization makes unspent_coin_count difficult
                        "set_remainder": True,
                    },
                    "cat_taker": {
                        "confirmed_wallet_balance": -CAT_REQUESTED,
                        ">=#spendable_balance": 1,
                        ">=#max_send_amount": 1,
                        "<=#pending_change": -1,
                        "pending_coin_removal_count": -1,
                    },
                    "nft0": {
                        "unspent_coin_count": -1,
                        "pending_coin_removal_count": -1,
                    },
                },
            ),
        ]
    )

    # Now let's make sure the final wallet state is correct
    await time_out_assert(20, get_nft_count, 3, basic_nft_wallet_maker)
    await time_out_assert(20, get_nft_count, 0, basic_nft_wallet_taker)
    assert await basic_nft_wallet_maker.nft_store.get_nft_by_id(nft_to_offer_asset_id_maker) is not None
