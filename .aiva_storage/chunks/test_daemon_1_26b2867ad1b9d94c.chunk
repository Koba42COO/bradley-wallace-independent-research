"
    data = {"service": service_name}
    payload = create_payload("register_service", data, "chia_plotter", "daemon")
    await ws.send_str(payload)
    response = await ws.receive()
    assert_response_success_only(response)

    case.request["t"] = str(get_b_tools.root_path)
    case.request["d"] = str(get_b_tools.root_path)

    payload_rpc = create_payload_dict(
        case.route,
        case.request,
        "test_service_name",
        "daemon",
    )
    payload = dict_to_json_str(payload_rpc)
    await ws.send_str(payload)
    response = await ws.receive()

    assert_response_success_only(response, payload_rpc["request_id"])


def assert_plot_queue_response(
    response: aiohttp.http_websocket.WSMessage,
    expected_command: str,
    expected_message_state: str,
    expected_plot_id: str,
    expected_plot_state: str,
) -> None:
    assert response.type == aiohttp.WSMsgType.TEXT
    message = json.loads(response.data.strip())
    assert message["command"] == expected_command
    assert message["data"]["state"] == expected_message_state
    plot_info = message["data"]["queue"][0]
    assert plot_info["id"] == expected_plot_id
    assert plot_info["state"] == expected_plot_state


def check_plot_queue_log(
    response: aiohttp.http_websocket.WSMessage,
    expected_command: str,
    expected_message_state: str,
    expected_plot_id: str,
    expected_plot_state: str,
    expected_log_entry: str,
) -> bool:
    assert_plot_queue_response(
        response, expected_command, expected_message_state, expected_plot_id, expected_plot_state
    )

    message = json.loads(response.data.strip())
    plot_info = message["data"]["queue"][0]

    return plot_info["log_new"].startswith(expected_log_entry)


@pytest.mark.anyio
async def test_plotter_roundtrip(
    daemon_connection_and_temp_keychain: tuple[aiohttp.ClientWebSocketResponse, Keychain], get_b_tools: BlockTools
) -> None:
    ws, _keychain = daemon_connection_and_temp_keychain

    # register for chia_plotter events
    service_name = "chia_plotter"
    data = {"service": service_name}
    payload = create_payload("register_service", data, "chia_plotter", "daemon")
    await ws.send_str(payload)
    response = await ws.receive()
    assert_response_success_only(response)

    root_path = get_b_tools.root_path

    plotting_request: dict[str, Any] = {
        **plotter_request_ref,
        "d": str(root_path),
        "t": str(root_path),
        "p": "xxx",
    }
    plotting_request.pop("c", None)

    payload_rpc = create_payload_dict(
        "start_plotting",
        plotting_request,
        "test_service_name",
        "daemon",
    )
    payload = dict_to_json_str(payload_rpc)
    await ws.send_str(payload)

    # should first get response to start_plottin
    response = await ws.receive()
    assert response.type == aiohttp.WSMsgType.TEXT
    message = json.loads(response.data.strip())
    assert message["data"]["success"] is True
    assert message["request_id"] == payload_rpc["request_id"]
    plot_id = message["data"]["ids"][0]

    # 1) Submitted
    response = await ws.receive()
    assert_plot_queue_response(response, "state_changed", "state_changed", plot_id, "SUBMITTED")

    # 2) Running
    response = await ws.receive()
    assert_plot_queue_response(response, "state_changed", "state_changed", plot_id, "RUNNING")

    # Write chiapos magic words to the log file to signal finished
    plot_log_path = plotter_log_path(root_path, plot_id)
    with open(plot_log_path, "a") as f:
        f.write("Renamed final file")
        f.flush()

    # 3) log_changed
    final_log_entry = False
    while not final_log_entry:
        response = await ws.receive()
        final_log_entry = check_plot_queue_log(
            response, "state_changed", "log_changed", plot_id, "RUNNING", "Renamed final file"
        )
        if not final_log_entry:
            with open(plot_log_path, "a") as f:
                f.write("Renamed final file")
                f.flush()

    # 4) Finished
    response = await ws.receive()
    assert_plot_queue_response(response, "state_changed", "state_changed", plot_id, "FINISHED")


@pytest.mark.anyio
async def test_plotter_stop_plotting(
    daemon_connection_and_temp_keychain: tuple[aiohttp.ClientWebSocketResponse, Keychain], get_b_tools: BlockTools
) -> None:
    ws, _keychain = daemon_connection_and_temp_keychain

    # register for chia_plotter events
    service_name = "chia_plotter"
    data = {"service": service_name}
    payload = create_payload("register_service", data, "chia_plotter", "daemon")
    await ws.send_str(payload)
    response = await ws.receive()
    assert_response_success_only(response)

    root_path = get_b_tools.root_path

    plotting_request: dict[str, Any] = {
        **plotter_request_ref,
        "d": str(root_path),
        "t": str(root_path),
    }

    payload_rpc = create_payload_dict(
        "start_plotting",
        plotting_request,
        "test_service_name",
        "daemon",
    )
    payload = dict_to_json_str(payload_rpc)
    await ws.send_str(payload)

    # should first get response to start_plotting
    response = await ws.receive()
    assert response.type == aiohttp.WSMsgType.TEXT
    message = json.loads(response.data.strip())
    assert message["data"]["success"] is True
    # make sure matches the start_plotting request
    assert message["request_id"] == payload_rpc["request_id"]
    plot_id = message["data"]["ids"][0]

    # 1) Submitted
    response = await ws.receive()
    assert_plot_queue_response(response, "state_changed", "state_changed", plot_id, "SUBMITTED")

    # 2) Running
    response = await ws.receive()
    assert_plot_queue_response(response, "state_changed", "state_changed", plot_id, "RUNNING")

    payload_rpc = create_payload_dict(
        "stop_plotting",
        {"id": plot_id},
        "service_name",
        "daemon",
    )

    stop_plotting_request_id = payload_rpc["request_id"]
    payload = dict_to_json_str(payload_rpc)
    await ws.send_str(payload)

    responses: list[WSMessage] = []

    # 3, 4, and 5)
    #   Removing
    #   Finished
    #   Finally, get the "ack" for the stop_plotting payload
    for _ in range(3):
        responses.append(await ws.receive())

    state_changes: list[WSMessage] = []
    finished: list[WSMessage] = []

    for response in responses:
        message = json.loads(response.data.strip())
        command = message.get("command")
        if command == "state_changed":
            state_changes.append(response)
        else:
            finished.append(response)

    assert len(state_changes) == 2
    assert len(finished) == 1

    assert_plot_queue_response(state_changes[0], "state_changed", "state_changed", plot_id, "REMOVING")
    assert_plot_queue_response(state_changes[1], "state_changed", "state_changed", plot_id, "FINISHED")
    assert_response(finished[0], {"success": True}, stop_plotting_request_id)


@datacases(
    ChiaPlottersBladebitArgsCase(case_id="1", plot_type="cudaplot"),
    ChiaPlottersBladebitArgsCase(case_id="2", plot_type="cudaplot", hybrid_disk_mode=16),
    ChiaPlottersBladebitArgsCase(case_id="3", plot_type="cudaplot", hybrid_disk_mode=128),
)
def test_run_plotter_bladebit(
    mocker: MockerFixture,
    mock_daemon_with_config_and_keys,
    bt: BlockTools,
    case: ChiaPlottersBladebitArgsCase,
) -> None:
    root_path = bt.root_path

    case.farmer_pk = bytes(bt.farmer_pk).hex()
    case.final_dir = str(bt.plot_dir)

    def bladebit_exists(x: Path) -> bool:
        return True if isinstance(x, Path) and x.parent == root_path / "plotters" else mocker.DEFAULT

    def get_bladebit_version(_: Path) -> tuple[bool, list[str]]:
        return True, ["3", "0", "0"]

    mocker.patch("os.path.exists", side_effect=bladebit_exists)
    mocker.patch("chia.plotters.bladebit.get_bladebit_version", side_effect=get_bladebit_version)
    mock_run_plotter = mocker.patch("chia.plotters.bladebit.run_plotter")

    call_plotters(root_path, case.to_command_array())

    assert mock_run_plotter.call_args.args[0] == root_path
    assert mock_run_plotter.call_args.args[1] == "bladebit"
    assert mock_run_plotter.call_args.args[2][1:] == case.expected_raw_command_args()
    mock_run_plotter.assert_called_once()


@pytest.mark.anyio
async def test_message_logging_redaction(
    daemon_connection_and_temp_keychain: tuple[aiohttp.ClientWebSocketResponse, Keychain],
    caplog: pytest.LogCaptureFixture,
) -> None:
    ws, _ = daemon_connection_and_temp_keychain

    with caplog.at_level(logging.DEBUG, logger="chia.daemon.server"):
        sensitive_payload = create_payload(
            "test_command",
            {
                "password": "secret_password",
                "private_key": "sensitive_key_data",
                "secret_value": "very_secret",
                "mnemonic": "test_mnemonic_phrase",
                "normal_field": "normal_value",
                "nested_object": {
                    "passphrase": "nested_secret",
                    "api_key": "nested_api_key",
                    "seed_mnemonic": "nested_mnemonic",
                    "safe_field": "safe_value",
                },
            },
            "test",
            "daemon",
        )

        original_message = json.loads(sensitive_payload)
        request_id = original_message["request_id"]

        await ws.send_str(sensitive_payload)
        await ws.receive()

        log_message = next(record for record in caplog.records if "Received message:" in record.message).message
        _, _, ws_message_str = log_message.partition("Received message: ")

        # Build the expected redacted structure and sort keys like dict_to_json_str does
        expected_redacted_data = {
            "ack": False,
            "command": "test_command",
            "data": {
                "mnemonic": "***<redacted>***",
                "nested_object": {
                    "api_key": "***<redacted>***",
                    "passphrase": "***<redacted>***",
                    "safe_field": "safe_value",
                    "seed_mnemonic": "***<redacted>***",
                },
                "normal_field": "normal_value",
                "password": "***<redacted>***",
                "private_key": "***<redacted>***",
                "secret_value": "***<redacted>***",
            },
            "destination": "daemon",
            "origin": "test",
            "request_id": request_id,
        }

        expected_ws_message = f"WSMessage(type=<WSMsgType.TEXT: 1>, data={expected_redacted_data!r}, extra='')"

        assert ws_message_str == expected_ws_message


@pytest.mark.anyio
async def test_non_text_message_logging(
    daemon_connection_and_temp_keychain: tuple[aiohttp.ClientWebSocketResponse, Keychain],
    caplog: pytest.LogCaptureFixture,
) -> None:
    ws, _ = daemon_connection_and_temp_keychain

    with caplog.at_level(logging.DEBUG, logger="chia.daemon.server"):
        # Close the websocket to trigger non-text message handling
        await ws.close()

        non_text_logs = [record for record in caplog.records if "Received non-text message" in record.message]

        assert len(non_text_logs) == 1, "Expected one 'Received non-text message' log entry"
